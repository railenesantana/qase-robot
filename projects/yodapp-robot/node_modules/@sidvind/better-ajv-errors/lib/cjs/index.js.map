{
  "version": 3,
  "sources": ["../../node_modules/leven/index.js", "../../node_modules/jsonpointer/jsonpointer.js", "../../src/index.js", "../../node_modules/@humanwhocodes/momoa/dist/momoa.js", "../../src/utils.js", "../../src/validation-errors/required.js", "../../src/validation-errors/base.js", "../../src/json/utils.js", "../../src/json/get-meta-from-path.js", "../../src/json/get-decorated-data-path.js", "../../src/validation-errors/additional-prop.js", "../../src/validation-errors/enum.js", "../../src/validation-errors/default.js", "../../src/helpers.js"],
  "sourcesContent": ["'use strict';\nconst array = [];\nconst charCodeCache = [];\n\nconst leven = (left, right) => {\n\tif (left === right) {\n\t\treturn 0;\n\t}\n\n\tconst swap = left;\n\n\t// Swapping the strings if `a` is longer than `b` so we know which one is the\n\t// shortest & which one is the longest\n\tif (left.length > right.length) {\n\t\tleft = right;\n\t\tright = swap;\n\t}\n\n\tlet leftLength = left.length;\n\tlet rightLength = right.length;\n\n\t// Performing suffix trimming:\n\t// We can linearly drop suffix common to both strings since they\n\t// don't increase distance at all\n\t// Note: `~-` is the bitwise way to perform a `- 1` operation\n\twhile (leftLength > 0 && (left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength))) {\n\t\tleftLength--;\n\t\trightLength--;\n\t}\n\n\t// Performing prefix trimming\n\t// We can linearly drop prefix common to both strings since they\n\t// don't increase distance at all\n\tlet start = 0;\n\n\twhile (start < leftLength && (left.charCodeAt(start) === right.charCodeAt(start))) {\n\t\tstart++;\n\t}\n\n\tleftLength -= start;\n\trightLength -= start;\n\n\tif (leftLength === 0) {\n\t\treturn rightLength;\n\t}\n\n\tlet bCharCode;\n\tlet result;\n\tlet temp;\n\tlet temp2;\n\tlet i = 0;\n\tlet j = 0;\n\n\twhile (i < leftLength) {\n\t\tcharCodeCache[i] = left.charCodeAt(start + i);\n\t\tarray[i] = ++i;\n\t}\n\n\twhile (j < rightLength) {\n\t\tbCharCode = right.charCodeAt(start + j);\n\t\ttemp = j++;\n\t\tresult = j;\n\n\t\tfor (i = 0; i < leftLength; i++) {\n\t\t\ttemp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;\n\t\t\ttemp = array[i];\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\tresult = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nmodule.exports = leven;\n// TODO: Remove this for the next major release\nmodule.exports.default = leven;\n", "var hasExcape = /~/\nvar escapeMatcher = /~[01]/g\nfunction escapeReplacer (m) {\n  switch (m) {\n    case '~1': return '/'\n    case '~0': return '~'\n  }\n  throw new Error('Invalid tilde escape: ' + m)\n}\n\nfunction untilde (str) {\n  if (!hasExcape.test(str)) return str\n  return str.replace(escapeMatcher, escapeReplacer)\n}\n\nfunction setter (obj, pointer, value) {\n  var part\n  var hasNextPart\n\n  for (var p = 1, len = pointer.length; p < len;) {\n    if (pointer[p] === 'constructor' || pointer[p] === 'prototype' || pointer[p] === '__proto__') return obj\n\n    part = untilde(pointer[p++])\n    hasNextPart = len > p\n\n    if (typeof obj[part] === 'undefined') {\n      // support setting of /-\n      if (Array.isArray(obj) && part === '-') {\n        part = obj.length\n      }\n\n      // support nested objects/array when setting values\n      if (hasNextPart) {\n        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []\n        else obj[part] = {}\n      }\n    }\n\n    if (!hasNextPart) break\n    obj = obj[part]\n  }\n\n  var oldValue = obj[part]\n  if (value === undefined) delete obj[part]\n  else obj[part] = value\n  return oldValue\n}\n\nfunction compilePointer (pointer) {\n  if (typeof pointer === 'string') {\n    pointer = pointer.split('/')\n    if (pointer[0] === '') return pointer\n    throw new Error('Invalid JSON pointer.')\n  } else if (Array.isArray(pointer)) {\n    for (const part of pointer) {\n      if (typeof part !== 'string' && typeof part !== 'number') {\n        throw new Error('Invalid JSON pointer. Must be of type string or number.')\n      }\n    }\n    return pointer\n  }\n\n  throw new Error('Invalid JSON pointer.')\n}\n\nfunction get (obj, pointer) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  var len = pointer.length\n  if (len === 1) return obj\n\n  for (var p = 1; p < len;) {\n    obj = obj[untilde(pointer[p++])]\n    if (len === p) return obj\n    if (typeof obj !== 'object' || obj === null) return undefined\n  }\n}\n\nfunction set (obj, pointer, value) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')\n  return setter(obj, pointer, value)\n}\n\nfunction compile (pointer) {\n  var compiled = compilePointer(pointer)\n  return {\n    get: function (object) {\n      return get(object, compiled)\n    },\n    set: function (object, value) {\n      return set(object, compiled, value)\n    }\n  }\n}\n\nexports.get = get\nexports.set = set\nexports.compile = compile\n", "import { parse } from '@humanwhocodes/momoa';\nimport prettify from './helpers';\n\nexport default (schema, data, errors, options = {}) => {\n  const { format = 'cli', indent = null, json = null } = options;\n\n  const jsonRaw = json || JSON.stringify(data, null, indent);\n  const jsonAst = parse(jsonRaw);\n\n  const customErrorToText = error => error.print().join('\\n');\n  const customErrorToStructure = error => error.getError();\n  const customErrors = prettify(errors, {\n    data,\n    schema,\n    jsonAst,\n    jsonRaw,\n  });\n\n  if (format === 'cli') {\n    return customErrors.map(customErrorToText).join('\\n\\n');\n  } else {\n    return customErrors.map(customErrorToStructure);\n  }\n};\n", "/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typings\").TokenType} TokenType */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\n\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\n\nconst QUOTE$1 = \"\\\"\";\n\nconst expectedKeywords = new Map([\n    [\"t\", TRUE],\n    [\"f\", FALSE],\n    [\"n\", NULL]\n]);\n\nconst escapeToChar = new Map([\n    [QUOTE$1, QUOTE$1],\n    [\"\\\\\", \"\\\\\"],\n    [\"/\", \"/\"],\n    [\"b\", \"\\b\"],\n    [\"n\", \"\\n\"],\n    [\"f\", \"\\f\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"]\n]);\n\n/** @type {Map<string,TokenType>} */\nconst knownTokenTypes = new Map([\n    [LBRACKET, \"LBracket\"],\n    [RBRACKET, \"RBracket\"],\n    [LBRACE, \"LBrace\"],\n    [RBRACE, \"RBrace\"],\n    [COLON, \"Colon\"],\n    [COMMA, \"Comma\"],\n    [TRUE, \"Boolean\"],\n    [FALSE, \"Boolean\"],\n    [NULL, \"Null\"]\n]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typings\").Location} Location */\n/** @typedef {import(\"./typings\").Token} Token */\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} message The error message to report. \n     * @param {Location} loc The location information for the error.\n     */\n    constructor(message, { line, column, offset }) {\n        super(`${ message } (${ line }:${ column})`);\n\n        /**\n         * The line on which the error occurred.\n         * @type number\n         * @property line\n         */\n        this.line = line;\n\n        /**\n         * The column on which the error occurred.\n         * @type number\n         * @property column\n         */\n        this.column = column;\n        \n        /**\n         * The index into the string where the error occurred.\n         * @type number\n         * @property offset\n         */\n        this.offset = offset;\n    }\n\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} unexpected The character that was found.\n     * @param {Location} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected character '${ unexpected }' found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Token} token The token that was found. \n     */\n    constructor(token) {\n        super(`Unexpected token ${ token.type } found.`, token.loc.start);\n    }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Location} loc The location information for the found character.\n     */\n    constructor(loc) {\n        super(\"Unexpected end of input found.\", loc);\n    }\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typings\").TokenizeOptions} TokenizeOptions */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst QUOTE = \"\\\"\";\nconst SLASH = \"/\";\nconst STAR = \"*\";\n\nconst DEFAULT_OPTIONS$1 = {\n    mode: \"json\",\n    ranges: false\n};\n\nfunction isWhitespace(c) {\n    return /[\\s\\n]/.test(c);\n}\n\nfunction isDigit(c) {\n    return c >= \"0\" && c <= \"9\";\n}\n\nfunction isHexDigit(c) {\n    return isDigit(c) || /[a-f]/i.test(c);\n}\n\nfunction isPositiveDigit(c) {\n    return c >= \"1\" && c <= \"9\";\n}\n\nfunction isKeywordStart(c) {\n    return /[tfn]/.test(c);\n}\n\nfunction isNumberStart(c) {\n    return isDigit(c) || c === \".\" || c === \"-\";\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @param {TokenizeOptions} options Options for doing the tokenization.\n * @returns {Array<Token>} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS$1,\n        ...options\n    });\n\n    let offset = -1;\n    let line = 1;\n    let column = 0;\n    let newLine = false;\n\n    const tokens = [];\n\n    /**\n     * Creates a new token.\n     * @param {TokenType} tokenType The type of token to create. \n     * @param {string} value The value of the token. \n     * @param {Location} startLoc The start location for the token.\n     * @param {Location} [endLoc] The end location for the token.\n     * @returns {Token} The token.\n     */\n    function createToken(tokenType, value, startLoc, endLoc) {\n        \n        const endOffset = startLoc.offset + value.length;\n\n        let range = options.ranges ? {\n            range: [startLoc.offset, endOffset]\n        } : undefined;\n\n        return {\n            type: tokenType,\n            loc: {\n                start: startLoc,\n                end: endLoc || {\n                    line: startLoc.line,\n                    column: startLoc.column + value.length,\n                    offset: endOffset\n                }\n            },\n            ...range\n        };\n    }\n\n    function next() {\n        let c = text.charAt(++offset);\n    \n        if (newLine) {\n            line++;\n            column = 1;\n            newLine = false;\n        } else {\n            column++;\n        }\n\n        if (c === \"\\r\") {\n            newLine = true;\n\n            // if we already see a \\r, just ignore upcoming \\n\n            if (text.charAt(offset + 1) === \"\\n\") {\n                offset++;\n            }\n        } else if (c === \"\\n\") {\n            newLine = true;\n        }\n\n        return c;\n    }\n\n    function locate() {\n        return {\n            line,\n            column,\n            offset\n        };\n    }\n\n    function readKeyword(c) {\n\n        // get the expected keyword\n        let value = expectedKeywords.get(c);\n\n        // check to see if it actually exists\n        if (text.slice(offset, offset + value.length) === value) {\n            offset += value.length - 1;\n            column += value.length - 1;\n            return { value, c: next() };\n        }\n\n        // find the first unexpected character\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] !== text.charAt(offset + j)) {\n                unexpected(next());\n            }\n        }\n\n    }\n\n    function readString(c) {\n        let value = c;\n        c = next();\n\n        while (c && c !== QUOTE) {\n\n            // escapes\n            if (c === \"\\\\\") {\n                value += c;\n                c = next();\n\n                if (escapeToChar.has(c)) {\n                    value += c;\n                } else if (c === \"u\") {\n                    value += c;\n                    for (let i = 0; i < 4; i++) {\n                        c = next();\n                        if (isHexDigit(c)) {\n                            value += c;\n                        } else {\n                            unexpected(c);\n                        }\n                    }\n                } else {\n                    unexpected(c);\n                }\n            } else {\n                value += c;\n            }\n\n            c = next();\n        }\n\n        if (!c) {\n            unexpectedEOF();\n        }\n        \n        value += c;\n\n        return { value, c: next() };\n    }\n\n\n    function readNumber(c) {\n\n        let value = \"\";\n\n        // Number may start with a minus but not a plus\n        if (c === \"-\") {\n\n            value += c;\n\n            c = next();\n\n            // Next digit cannot be zero\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n        }\n\n        // Zero must be followed by a decimal point or nothing\n        if (c === \"0\") {\n\n            value += c;\n\n            c = next();\n            if (isDigit(c)) {\n                unexpected(c);\n            }\n\n        } else {\n            if (!isPositiveDigit(c)) {\n                unexpected(c);\n            }\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Decimal point may be followed by any number of digits\n        if (c === \".\") {\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Exponent is always last\n        if (c === \"e\" || c === \"E\") {\n\n            value += c;\n            c = next();\n\n            if (c === \"+\" || c === \"-\") {\n                value += c;\n                c = next();\n            }\n\n            /*\n             * Must always have a digit in this position to avoid:\n             * 5e\n             * 12E+\n             * 42e-\n             */\n            if (!c) {\n                unexpectedEOF();\n            }\n\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n            while (isDigit(c)) {\n                value += c;\n                c = next();\n            }\n        }\n\n\n        return { value, c };\n    }\n\n    /**\n     * Reads in either a single-line or multi-line comment.\n     * @param {string} c The first character of the comment.\n     * @returns {{value:string, c:string}} The comment string.\n     * @throws {UnexpectedChar} when the comment cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the comment is\n     *      finalized.\n     */\n    function readComment(c) {\n\n        let value = c;\n\n        // next character determines single- or multi-line\n        c = next();\n\n        // single-line comments\n        if (c === \"/\") {\n            \n            do {\n                value += c;\n                c = next();\n            } while (c && c !== \"\\r\" && c !== \"\\n\");\n\n            return { value, c };\n        }\n\n        // multi-line comments\n        if (c === STAR) {\n\n            while (c) {\n                value += c;\n                c = next();\n\n                // check for end of comment\n                if (c === STAR) {\n                    value += c;\n                    c = next();\n                    \n                    //end of comment\n                    if (c === SLASH) {\n                        value += c;\n\n                        /*\n                         * The single-line comment functionality cues up the\n                         * next character, so we do the same here to avoid\n                         * splitting logic later.\n                         */\n                        c = next();\n                        return { value, c };\n                    }\n                }\n            }\n\n            unexpectedEOF();\n            \n        }\n\n        // if we've made it here, there's an invalid character\n        unexpected(c);        \n    }\n\n\n    /**\n     * Convenience function for throwing unexpected character errors.\n     * @param {string} c The unexpected character.\n     * @returns {void}\n     * @throws {UnexpectedChar} always.\n     */\n    function unexpected(c) {\n        throw new UnexpectedChar(c, locate());\n    }\n\n    /**\n     * Convenience function for throwing unexpected EOF errors.\n     * @returns {void}\n     * @throws {UnexpectedEOF} always.\n     */\n    function unexpectedEOF() {\n        throw new UnexpectedEOF(locate());\n    }\n\n    let c = next();\n\n    while (offset < text.length) {\n\n        while (isWhitespace(c)) {\n            c = next();\n        }\n\n        if (!c) {\n            break;\n        }\n\n        const start = locate();\n\n        // check for easy case\n        if (knownTokenTypes.has(c)) {\n            tokens.push(createToken(knownTokenTypes.get(c), c, start));\n            c = next();\n        } else if (isKeywordStart(c)) {\n            const result = readKeyword(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(knownTokenTypes.get(value), value, start));\n        } else if (isNumberStart(c)) {\n            const result = readNumber(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"Number\", value, start));\n        } else if (c === QUOTE) {\n            const result = readString(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"String\", value, start));\n        } else if (c === SLASH && options.mode === \"jsonc\") {\n            const result = readComment(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(value.startsWith(\"//\") ? \"LineComment\" : \"BlockComment\", value, start, locate()));\n        } else {\n            unexpected(c);\n        }\n    }\n\n    return tokens;\n\n}\n\n/**\n * @fileoverview  JSON AST types\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typings\").NodeParts} NodeParts */\n/** @typedef {import(\"./typings\").DocumentNode} DocumentNode */\n/** @typedef {import(\"./typings\").StringNode} StringNode */\n/** @typedef {import(\"./typings\").NumberNode} NumberNode */\n/** @typedef {import(\"./typings\").BooleanNode} BooleanNode */\n/** @typedef {import(\"./typings\").MemberNode} MemberNode */\n/** @typedef {import(\"./typings\").ObjectNode} ObjectNode */\n/** @typedef {import(\"./typings\").ElementNode} ElementNode */\n/** @typedef {import(\"./typings\").ArrayNode} ArrayNode */\n/** @typedef {import(\"./typings\").NullNode} NullNode */\n/** @typedef {import(\"./typings\").ValueNode} ValueNode */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nconst types = {\n\n    /**\n     * Creates a document node.\n     * @param {ValueNode} body The body of the document.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {DocumentNode} The document node.\n     */\n    document(body, parts = {}) {\n        return {\n            type: \"Document\",\n            body,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a string node.\n     * @param {string} value The value for the string.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {StringNode} The string node.\n     */\n    string(value, parts = {}) {\n        return {\n            type: \"String\",\n            value,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a number node.\n     * @param {number} value The value for the number.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {NumberNode} The number node.\n     */\n    number(value, parts = {}) {\n        return {\n            type: \"Number\",\n            value,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a boolean node.\n     * @param {boolean} value The value for the boolean.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {BooleanNode} The boolean node.\n     */\n    boolean(value, parts = {}) {\n        return {\n            type: \"Boolean\",\n            value,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a null node.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {NullNode} The null node.\n     */\n    null(parts = {}) {\n        return {\n            type: \"Null\",\n            ...parts\n        };\n    },\n\n    /**\n     * Creates an array node.\n     * @param {Array<ElementNode>} elements The elements to add.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {ArrayNode} The array node.\n     */\n    array(elements, parts = {}) {\n        return {\n            type: \"Array\",\n            elements,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates an element node.\n     * @param {ValueNode} value The value for the element.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {ElementNode} The element node.\n     */\n    element(value, parts = {}) {\n        return {\n            type: \"Element\",\n            value,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates an object node.\n     * @param {Array<MemberNode>} members The members to add.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {ObjectNode} The object node.\n     */\n    object(members, parts = {}) {\n        return {\n            type: \"Object\",\n            members,\n            ...parts\n        };\n    },\n\n    /**\n     * Creates a member node.\n     * @param {StringNode} name The name for the member.\n     * @param {ValueNode} value The value for the member.\n     * @param {NodeParts} parts Additional properties for the node. \n     * @returns {MemberNode} The member node.\n     */\n    member(name, value, parts = {}) {\n        return {\n            type: \"Member\",\n            name,\n            value,\n            ...parts\n        };\n    },\n\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typings\").Node} Node */\n/** @typedef {import(\"./typings\").Mode} Mode */\n/** @typedef {import(\"./typings\").ParseOptions} ParseOptions */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/** @type {ParseOptions} */\nconst DEFAULT_OPTIONS = {\n    mode: \"json\",\n    ranges: false,\n    tokens: false\n};\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {string} value The text for the token.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(value, token) {\n    \n    let result = \"\";\n    let escapeIndex = value.indexOf(\"\\\\\");\n    let lastIndex = 0;\n\n    // While there are escapes, interpret them to build up the result\n    while (escapeIndex >= 0) {\n\n        // append the text that happened before the escape\n        result += value.slice(lastIndex, escapeIndex);\n\n        // get the character immediately after the \\\n        const escapeChar = value.charAt(escapeIndex + 1);\n        \n        // check for the non-Unicode escape sequences first\n        if (escapeToChar.has(escapeChar)) {\n            result += escapeToChar.get(escapeChar);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeChar === \"u\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n            if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid unicode escape \\\\u${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n            \n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 6;\n        } else {\n            throw new ErrorWithLocation(\n                `Invalid escape \\\\${ escapeChar }.`,\n                {\n                    line: token.loc.start.line,\n                    column: token.loc.start.column + escapeIndex,\n                    offset: token.loc.start.offset + escapeIndex\n                }\n            );\n        }\n\n        // find the next escape sequence\n        escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n    }\n\n    // get the last segment of the string value\n    result += value.slice(lastIndex);\n\n    return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {string} value The text value of the token.\n * @param {Token} token The JSON token to get a value for.\n * @returns {string|boolean|number} A number, string, or boolean.\n * @throws {TypeError} If an unknown token type is found. \n */\nfunction getLiteralValue(value, token) {\n    switch (token.type) {\n        case \"Boolean\":\n            return value === \"true\";\n            \n        case \"Number\":\n            return Number(value);\n\n        case \"String\":\n            return getStringValue(value.slice(1, -1), token);\n\n        default:\n            throw new TypeError(`Unknown token type \"${token.type}.`);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {ParseOptions} [options] The options object.\n * @returns {DocumentNode} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS,\n        ...options\n    });\n\n    const tokens = tokenize(text, {\n        mode: options.mode,\n        ranges: options.ranges\n    });\n\n    let tokenIndex = 0;\n\n    /**\n     * Returns the next token knowing there are no comments.\n     * @returns {Token|undefined} The next or undefined if no next token.\n     */\n    function nextNoComments() {\n        return tokens[tokenIndex++];\n    }\n    \n    /**\n     * Returns the next token knowing there are comments to skip.\n     * @returns {Token|undefined} The next or undefined if no next token.\n     */\n    function nextSkipComments() {\n        const nextToken = tokens[tokenIndex++];\n        if (nextToken && nextToken.type.endsWith(\"Comment\")) {\n            return nextSkipComments();\n        }\n\n        return nextToken;\n\n    }\n\n    // determine correct way to evaluate tokens based on presence of comments\n    const next = options.mode === \"jsonc\" ? nextSkipComments : nextNoComments;\n\n    /**\n     * Asserts a token has the given type.\n     * @param {Token} token The token to check.\n     * @param {string} type The token type.\n     * @throws {UnexpectedToken} If the token type isn't expected.\n     * @returns {void}\n     */\n    function assertTokenType(token, type) {\n        if (!token || token.type !== type) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    /**\n     * Creates a range only if ranges are specified.\n     * @param {Location} start The start offset for the range.\n     * @param {Location} end The end offset for the range.\n     * @returns {{range:number[]}|undefined} An object with a \n     */\n    function createRange(start, end) {\n        // @ts-ignore tsc incorrect - options might be undefined\n        return options.ranges ? {\n            range: [start.offset, end.offset]\n        } : undefined;\n    }\n\n    /**\n     * Creates a node for a string, boolean, or number.\n     * @param {Token} token The token representing the literal. \n     * @returns {StringNode|NumberNode|BooleanNode} The node representing\n     *      the value.\n     */\n    function createLiteralNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n        const value = getLiteralValue(\n            text.slice(token.loc.start.offset, token.loc.end.offset),\n            token\n        );\n        const loc = {\n            start: {\n                ...token.loc.start\n            },\n            end: {\n                ...token.loc.end\n            }\n        };\n        const parts = { loc, ...range };\n\n        switch (token.type) {\n            case \"String\":\n                return types.string(/** @type {string} */ (value), parts);\n\n            case \"Number\":\n                return types.number(/** @type {number} */ (value), parts);\n                \n            case \"Boolean\":\n                return types.boolean(/** @type {boolean} */ (value), parts);\n\n            default:\n                throw new TypeError(`Unknown token type ${token.type}.`);\n        }\n    }\n\n    /**\n     * Creates a node for a null.\n     * @param {Token} token The token representing null. \n     * @returns {NullNode} The node representing null.\n     */\n    function createNullNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n\n        return types.null({\n            loc: {\n                start: {\n                    ...token.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n\n    function parseProperty(token) {\n        assertTokenType(token, \"String\");\n        const name = createLiteralNode(token);\n\n        token = next();\n        assertTokenType(token, \"Colon\");\n        const value = parseValue();\n        const range = createRange(name.loc.start, value.loc.end);\n\n        return types.member(/** @type {StringNode} */ (name), value, {\n            loc: {\n                start: {\n                    ...name.loc.start\n                },\n                end: {\n                    ...value.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n    function parseObject(firstToken) {\n\n        // The first token must be a { or else it's an error\n        assertTokenType(firstToken, \"LBrace\");\n\n        const members = [];\n        let token = next();\n\n        if (token && token.type !== \"RBrace\") {\n            do {\n    \n                // add the value into the array\n                members.push(parseProperty(token));\n    \n                token = next();\n    \n                if (token.type === \"Comma\") {\n                    token = next();\n                } else {\n                    break;\n                }\n            } while (token);\n        }\n\n        assertTokenType(token, \"RBrace\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.object(members, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    function parseArray(firstToken) {\n\n        // The first token must be a [ or else it's an error\n        assertTokenType(firstToken, \"LBracket\");\n\n        const elements = [];\n        let token = next();\n        \n        if (token && token.type !== \"RBracket\") {\n\n            do {\n\n                // add the value into the array\n                const value = parseValue(token);\n\n                elements.push(types.element(\n                    value,\n                    { loc: value.loc }\n                ));\n\n                token = next();\n              \n                if (token.type === \"Comma\") {\n                    token = next();\n                } else {\n                    break;\n                }\n            } while (token);\n        }\n\n        assertTokenType(token, \"RBracket\");\n\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.array(elements, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    function parseValue(token) {\n\n        token = token || next();\n        \n        switch (token.type) {\n            case \"String\":\n            case \"Boolean\":\n            case \"Number\":\n                return createLiteralNode(token);\n\n            case \"Null\":\n                return createNullNode(token);\n\n            case \"LBrace\":\n                return parseObject(token);\n\n            case \"LBracket\":\n                return parseArray(token);\n\n            default:\n                throw new UnexpectedToken(token);\n        }\n\n    }\n\n    \n    const docBody = parseValue();\n    \n    const unexpectedToken = next();\n    if (unexpectedToken) {\n        throw new UnexpectedToken(unexpectedToken);\n    }\n    \n    \n    const docParts = {\n        loc: {\n            start: {\n                line: 1,\n                column: 1,\n                offset: 0\n            },\n            end: {\n                ...docBody.loc.end\n            }\n        }\n    };\n    \n    if (options.tokens) {\n        docParts.tokens = tokens;\n    }\n\n    if (options.ranges) {\n        docParts.range = [\n            docParts.loc.start.offset,\n            docParts.loc.end.offset\n        ];\n    }\n\n    return types.document(docBody, docParts);\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([\n    [\"Document\", [\"body\"]],\n    [\"Object\", [\"members\"]],\n    [\"Member\", [\"name\", \"value\"]],\n    [\"Element\", [\"value\"]],\n    [\"Array\", [\"elements\"]],\n    [\"String\", []],\n    [\"Number\", []],\n    [\"Boolean\", []],\n    [\"Null\", []]\n]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n    return value && (typeof value === \"object\");\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n    return isObject(value) && (typeof value.type === \"string\");\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {Object} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n\n    /**\n     * Recursively visits a node.\n     * @param {Node} node The node to visit.\n     * @param {Node} [parent] The parent of the node to visit.\n     * @returns {void}\n     */\n    function visitNode(node, parent) {\n\n        if (typeof visitor.enter === \"function\") {\n            visitor.enter(node, parent);\n        }\n\n        for (const key of childKeys.get(node.type)) {\n            const value = node[key];\n\n            if (isObject(value)) {\n                if (Array.isArray(value)) {\n                    value.forEach(child => visitNode(child, node));\n                } else if (isNode(value)) {\n                    visitNode(value, node);\n                }\n            }\n        }\n\n        if (typeof visitor.exit === \"function\") {\n            visitor.exit(node, parent);\n        }\n    }\n\n    visitNode(root);\n}\n\n/**\n * @callback FilterPredicate\n * @param {Node} node\n * @param {number} index\n * @param {Array<Node>} array\n * @returns {boolean}\n */\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {FilterPredicate} [filter] A filter function to determine which steps to\n *      return;\n * @returns {Iterator} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n\n    const traversal = [];\n\n    traverse(root, {\n        enter(node, parent) {\n            traversal.push({ node, parent, phase: \"enter\" });\n        },\n        exit(node, parent) {\n            traversal.push({ node, parent, phase: \"exit\" });\n        }\n    });\n\n    return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./typings\").AnyNode} AnyNode */\n/** @typedef {import(\"./typings\").JSONValue} JSONValue */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {AnyNode} node The node to interpet.\n * @returns {JSONValue} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n    switch (node.type) {\n        case \"String\":\n            return node.value;\n\n        case \"Number\":\n            return node.value;\n\n        case \"Boolean\":\n            return node.value;\n\n        case \"Null\":\n            return null;\n\n        case \"Array\": {\n            // const arrayNode = /** @type {ArrayNode} */ (node);\n            return node.elements.map(element => evaluate(element.value));\n        }\n\n        case \"Object\": {\n\n            /** @type {{[property: string]: JSONValue}} */\n            const object = {};\n\n            node.members.forEach(member => {\n                object[/** @type {string} */ (evaluate(member.name))] = evaluate(member.value);\n            });    \n\n            return object;\n        }    \n\n        case \"Document\": {\n            return evaluate(node.body);\n        }\n\n        case \"Element\":\n            throw new Error(\"Cannot evaluate array element outside of an array.\");\n\n        case \"Member\":\n            throw new Error(\"Cannot evaluate object member outside of an object.\");\n\n        default:\n            // @ts-ignore tsc doesn't know about the type property here?\n            throw new Error(`Unknown node type ${ node.type }.`);\n    }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {AnyNode} node The node to print.\n * @param {Object} options Options for the print.\n * @param {number} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, { indent = 0 } = {}) {\n    const value = evaluate(node);\n    return JSON.stringify(value, null, indent);\n}\n\nexport { evaluate, iterator, parse, print, tokenize, traverse, types };\n", "// Basic\nconst eq = x => y => x === y;\nconst not = fn => x => !fn(x);\n\nconst getValues = o => Object.values(o);\n\nexport const notUndefined = x => x !== undefined;\n\n// Error\nconst isXError = x => error => error.keyword === x;\nexport const isRequiredError = isXError('required');\nexport const isAnyOfError = isXError('anyOf');\nexport const isEnumError = isXError('enum');\nexport const getErrors = node =>\n  node && node.errors\n    ? node.errors.map(e =>\n        e.keyword === 'errorMessage'\n          ? { ...e.params.errors[0], message: e.message }\n          : e\n      )\n    : [];\n\n// Node\nexport const getChildren = node => (node && getValues(node.children)) || [];\n\nexport const getSiblings = parent => node =>\n  getChildren(parent).filter(not(eq(node)));\n\nexport const concatAll = xs => ys => ys.reduce((zs, z) => zs.concat(z), xs);\n", "import chalk from 'chalk';\nimport BaseValidationError from './base';\n\nexport default class RequiredValidationError extends BaseValidationError {\n  getLocation(dataPath = this.instancePath) {\n    const { start } = super.getLocation(dataPath);\n    return { start };\n  }\n\n  print() {\n    const { message, params } = this.options;\n    const output = [chalk`{red {bold REQUIRED} ${message}}\\n`];\n\n    return output.concat(\n      this.getCodeFrame(\n        chalk`\u2639\uFE0F  {magentaBright ${params.missingProperty}} is missing here!`\n      )\n    );\n  }\n\n  getError() {\n    const { message } = this.options;\n\n    return {\n      ...this.getLocation(),\n      error: `${this.getDecoratedPath()} ${message}`,\n      path: this.instancePath,\n    };\n  }\n}\n", "import { codeFrameColumns } from '@babel/code-frame';\nimport { getMetaFromPath, getDecoratedDataPath } from '../json';\n\nexport default class BaseValidationError {\n  constructor(\n    options = { isIdentifierLocation: false },\n    { data, schema, jsonAst, jsonRaw }\n  ) {\n    this.options = options;\n    this.data = data;\n    this.schema = schema;\n    this.jsonAst = jsonAst;\n    this.jsonRaw = jsonRaw;\n  }\n\n  getLocation(dataPath = this.instancePath) {\n    const { isIdentifierLocation, isSkipEndLocation } = this.options;\n    const { loc } = getMetaFromPath(\n      this.jsonAst,\n      dataPath,\n      isIdentifierLocation\n    );\n    return {\n      start: loc.start,\n      end: isSkipEndLocation ? undefined : loc.end,\n    };\n  }\n\n  getDecoratedPath(dataPath = this.instancePath) {\n    const decoratedPath = getDecoratedDataPath(this.jsonAst, dataPath);\n    return decoratedPath;\n  }\n\n  getCodeFrame(message, dataPath = this.instancePath) {\n    return codeFrameColumns(this.jsonRaw, this.getLocation(dataPath), {\n      highlightCode: true,\n      message,\n    });\n  }\n\n  /**\n   * @return {string}\n   */\n  get instancePath() {\n    return typeof this.options.instancePath !== 'undefined'\n      ? this.options.instancePath\n      : this.options.dataPath;\n  }\n\n  print() {\n    throw new Error(\n      `Implement the 'print' method inside ${this.constructor.name}!`\n    );\n  }\n\n  getError() {\n    throw new Error(\n      `Implement the 'getError' method inside ${this.constructor.name}!`\n    );\n  }\n}\n", "// TODO: Better error handling\nexport const getPointers = dataPath => {\n  return dataPath\n    .split('/')\n    .slice(1)\n    .map(pointer => pointer.split('~1').join('/').split('~0').join('~'));\n};\n", "import { getPointers } from './utils';\n\nexport default function getMetaFromPath(\n  jsonAst,\n  dataPath,\n  includeIdentifierLocation\n) {\n  const pointers = getPointers(dataPath);\n  const lastPointerIndex = pointers.length - 1;\n  return pointers.reduce((obj, pointer, idx) => {\n    switch (obj.type) {\n      case 'Object': {\n        const filtered = obj.members.filter(\n          child => child.name.value === pointer\n        );\n        if (filtered.length !== 1) {\n          throw new Error(`Couldn't find property ${pointer} of ${dataPath}`);\n        }\n\n        const { name, value } = filtered[0];\n        return includeIdentifierLocation && idx === lastPointerIndex\n          ? name\n          : value;\n      }\n      case 'Array':\n        return obj.elements[pointer].value;\n      default:\n        // eslint-disable-next-line no-console\n        console.log(obj);\n    }\n  }, jsonAst.body);\n}\n", "import { getPointers } from './utils';\n\nexport default function getDecoratedDataPath(jsonAst, dataPath) {\n  let decoratedPath = '';\n  getPointers(dataPath).reduce((obj, pointer) => {\n    switch (obj.type) {\n      case 'Element':\n        obj = obj.value;\n      /* eslint-disable-next-line no-fallthrough -- explicitly want fallthrough here */\n      case 'Object': {\n        decoratedPath += `/${pointer}`;\n        const filtered = obj.members.filter(\n          child => child.name.value === pointer\n        );\n        if (filtered.length !== 1) {\n          throw new Error(`Couldn't find property ${pointer} of ${dataPath}`);\n        }\n        return filtered[0].value;\n      }\n      case 'Array': {\n        decoratedPath += `/${pointer}${getTypeName(obj.elements[pointer])}`;\n        return obj.elements[pointer];\n      }\n      default:\n        // eslint-disable-next-line no-console\n        console.log(obj);\n    }\n  }, jsonAst.body);\n  return decoratedPath;\n}\n\nfunction getTypeName(obj) {\n  if (!obj || !obj.elements) {\n    return '';\n  }\n  const type = obj.elements.filter(\n    child => child && child.name && child.name.value === 'type'\n  );\n\n  if (!type.length) {\n    return '';\n  }\n\n  return (type[0].value && `:${type[0].value.value}`) || '';\n}\n", "import chalk from 'chalk';\nimport BaseValidationError from './base';\n\nexport default class AdditionalPropValidationError extends BaseValidationError {\n  constructor(...args) {\n    super(...args);\n    this.options.isIdentifierLocation = true;\n  }\n\n  print() {\n    const { message, params } = this.options;\n    const output = [chalk`{red {bold ADDTIONAL PROPERTY} ${message}}\\n`];\n\n    return output.concat(\n      this.getCodeFrame(\n        chalk`\uD83D\uDE32  {magentaBright ${params.additionalProperty}} is not expected to be here!`,\n        `${this.instancePath}/${params.additionalProperty}`\n      )\n    );\n  }\n\n  getError() {\n    const { params } = this.options;\n\n    return {\n      ...this.getLocation(`${this.instancePath}/${params.additionalProperty}`),\n      error: `${this.getDecoratedPath()} Property ${\n        params.additionalProperty\n      } is not expected to be here`,\n      path: this.instancePath,\n    };\n  }\n}\n", "import chalk from 'chalk';\nimport leven from 'leven';\nimport pointer from 'jsonpointer';\nimport BaseValidationError from './base';\n\nexport default class EnumValidationError extends BaseValidationError {\n  print() {\n    const {\n      message,\n      params: { allowedValues },\n    } = this.options;\n    const bestMatch = this.findBestMatch();\n\n    const output = [\n      chalk`{red {bold ENUM} ${message}}`,\n      chalk`{red (${allowedValues.join(', ')})}\\n`,\n    ];\n\n    return output.concat(\n      this.getCodeFrame(\n        bestMatch !== null\n          ? chalk`\uD83D\uDC48\uD83C\uDFFD  Did you mean {magentaBright ${bestMatch}} here?`\n          : chalk`\uD83D\uDC48\uD83C\uDFFD  Unexpected value, should be equal to one of the allowed values`\n      )\n    );\n  }\n\n  getError() {\n    const { message, params } = this.options;\n    const bestMatch = this.findBestMatch();\n    const allowedValues = params.allowedValues.join(', ');\n\n    const output = {\n      ...this.getLocation(),\n      error: `${this.getDecoratedPath()} ${message}: ${allowedValues}`,\n      path: this.instancePath,\n    };\n\n    if (bestMatch !== null) {\n      output.suggestion = `Did you mean ${bestMatch}?`;\n    }\n\n    return output;\n  }\n\n  findBestMatch() {\n    const {\n      params: { allowedValues },\n    } = this.options;\n\n    const currentValue =\n      this.instancePath === ''\n        ? this.data\n        : pointer.get(this.data, this.instancePath);\n\n    if (!currentValue) {\n      return null;\n    }\n\n    const bestMatch = allowedValues\n      .map(value => ({\n        value,\n        weight: leven(value, currentValue.toString()),\n      }))\n      .sort((x, y) =>\n        x.weight > y.weight ? 1 : x.weight < y.weight ? -1 : 0\n      )[0];\n\n    return allowedValues.length === 1 ||\n      bestMatch.weight < bestMatch.value.length\n      ? bestMatch.value\n      : null;\n  }\n}\n", "import chalk from 'chalk';\nimport BaseValidationError from './base';\n\nexport default class DefaultValidationError extends BaseValidationError {\n  print() {\n    const { keyword, message } = this.options;\n    const output = [chalk`{red {bold ${keyword.toUpperCase()}} ${message}}\\n`];\n\n    return output.concat(\n      this.getCodeFrame(chalk`\uD83D\uDC48\uD83C\uDFFD  {magentaBright ${keyword}} ${message}`)\n    );\n  }\n\n  getError() {\n    const { keyword, message } = this.options;\n\n    return {\n      ...this.getLocation(),\n      error: `${this.getDecoratedPath()}: ${keyword} ${message}`,\n      path: this.instancePath,\n    };\n  }\n}\n", "import {\n  getChildren,\n  getErrors,\n  getSiblings,\n  isAnyOfError,\n  isEnumError,\n  isRequiredError,\n  concatAll,\n  notUndefined,\n} from './utils';\nimport {\n  AdditionalPropValidationError,\n  RequiredValidationError,\n  EnumValidationError,\n  DefaultValidationError,\n} from './validation-errors/index';\n\nconst JSON_POINTERS_REGEX = /\\/[\\w_-]+(\\/\\d+)?/g;\n\n// Make a tree of errors from ajv errors array\nexport function makeTree(ajvErrors = []) {\n  const root = { children: {} };\n  ajvErrors.forEach(ajvError => {\n    const instancePath =\n      typeof ajvError.instancePath !== 'undefined'\n        ? ajvError.instancePath\n        : ajvError.dataPath;\n\n    // `dataPath === ''` is root\n    const paths =\n      instancePath === '' ? [''] : instancePath.match(JSON_POINTERS_REGEX);\n    paths &&\n      paths.reduce((obj, path, i) => {\n        obj.children[path] = obj.children[path] || { children: {}, errors: [] };\n        if (i === paths.length - 1) {\n          obj.children[path].errors.push(ajvError);\n        }\n        return obj.children[path];\n      }, root);\n  });\n  return root;\n}\n\nexport function filterRedundantErrors(root, parent, key) {\n  /**\n   * If there is a `required` error then we can just skip everythig else.\n   * And, also `required` should have more priority than `anyOf`. @see #8\n   */\n  getErrors(root).forEach(error => {\n    if (isRequiredError(error)) {\n      root.errors = [error];\n      root.children = {};\n    }\n  });\n\n  /**\n   * If there is an `anyOf` error that means we have more meaningful errors\n   * inside children. So we will just remove all errors from this level.\n   *\n   * If there are no children, then we don't delete the errors since we should\n   * have at least one error to report.\n   */\n  if (getErrors(root).some(isAnyOfError)) {\n    if (Object.keys(root.children).length > 0) {\n      delete root.errors;\n    }\n  }\n\n  /**\n   * If all errors are `enum` and siblings have any error then we can safely\n   * ignore the node.\n   *\n   * **CAUTION**\n   * Need explicit `root.errors` check because `[].every(fn) === true`\n   * https://en.wikipedia.org/wiki/Vacuous_truth#Vacuous_truths_in_mathematics\n   */\n  if (root.errors && root.errors.length && getErrors(root).every(isEnumError)) {\n    if (\n      getSiblings(parent)(root)\n        // Remove any reference which becomes `undefined` later\n        .filter(notUndefined)\n        .some(getErrors)\n    ) {\n      delete parent.children[key];\n    }\n  }\n\n  Object.entries(root.children).forEach(([key, child]) =>\n    filterRedundantErrors(child, root, key)\n  );\n}\n\nexport function createErrorInstances(root, options) {\n  const errors = getErrors(root);\n  if (errors.length && errors.every(isEnumError)) {\n    const uniqueValues = new Set(\n      concatAll([])(errors.map(e => e.params.allowedValues))\n    );\n    const allowedValues = [...uniqueValues];\n    const error = errors[0];\n    return [\n      new EnumValidationError(\n        {\n          ...error,\n          params: { allowedValues },\n        },\n        options\n      ),\n    ];\n  } else {\n    return concatAll(\n      errors.reduce((ret, error) => {\n        switch (error.keyword) {\n          case 'additionalProperties':\n            return ret.concat(\n              new AdditionalPropValidationError(error, options)\n            );\n          case 'enum':\n            return ret.concat(new EnumValidationError(error, options));\n          case 'required':\n            return ret.concat(new RequiredValidationError(error, options));\n          default:\n            return ret.concat(new DefaultValidationError(error, options));\n        }\n      }, [])\n    )(getChildren(root).map(child => createErrorInstances(child, options)));\n  }\n}\n\nexport default (ajvErrors, options) => {\n  const tree = makeTree(ajvErrors || []);\n  filterRedundantErrors(tree);\n  return createErrorInstances(tree, options);\n};\n"],
  "mappings": "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",
  "names": ["module", "leven", "pointer", "c", "pointer", "pointer", "pointer", "chalk", "import_chalk", "chalk", "import_chalk", "chalk", "pointer", "leven", "import_chalk", "chalk", "key"]
}
