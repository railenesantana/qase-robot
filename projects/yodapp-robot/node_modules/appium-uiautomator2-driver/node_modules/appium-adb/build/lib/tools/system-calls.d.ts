export default systemCallMethods;
export type ConnectedDevicesOptions = {
    /**
     * - Whether to get long output, which includes extra properties in each device.
     * Akin to running `adb devices -l`.
     */
    verbose?: boolean | undefined;
};
export type Device = {
    /**
     * - The device udid.
     */
    udid: string;
    /**
     * - Current device state, as it is visible in
     *   _adb devices -l_ output.
     */
    state: string;
    port?: number | undefined;
};
/**
 * Additional properties returned when `verbose` is true.
 */
export type VerboseDevice = Device;
export type ExecOutputFormat = "stdout" | "full";
export type ExecResult = {
    /**
     * The stdout received from exec
     */
    stdout: string;
    /**
     * The stderr received from exec
     */
    stderr: string;
};
export type SpecialAdbExecOptions = {
    exclusive?: boolean | undefined;
};
export type ShellExecOptions = {
    /**
     * - the name of the corresponding Appium's timeout capability
     * (used in the error messages).
     */
    timeoutCapName?: string | undefined;
    /**
     * - command execution timeout.
     */
    timeout?: number | undefined;
    /**
     * - Whether to run the given command as root.
     */
    privileged?: boolean | undefined;
    /**
     * - Whether response should include full exec output or just stdout.
     * Potential values are full or stdout.
     *
     * All other properties are the same as for `exec` call from {@link https://github.com/appium/node-teen_process}module
     */
    outputFormat?: ExecOutputFormat | undefined;
};
export type TFullOutputOption = {
    outputFormat: "full";
};
export type AvdLaunchOptions = {
    /**
     * Additional emulator command line arguments
     */
    args?: string | string[] | undefined;
    /**
     * Additional emulator environment variables
     */
    env?: any;
    /**
     * Emulator system language
     */
    language?: string | undefined;
    /**
     * Emulator system country
     */
    country?: string | undefined;
    /**
     * Emulator startup timeout in milliseconds
     */
    launchTimeout?: number | undefined;
    /**
     * The maximum period of time to wait until Emulator
     * is ready for usage in milliseconds
     */
    readyTimeout?: number | undefined;
    /**
     * The maximum number of startup retries
     */
    retryTimes?: number | undefined;
};
export type BinaryVersion = {
    /**
     * - The ADB binary version number
     */
    version: string;
    /**
     * - The ADB binary build number
     */
    build: number;
};
export type BridgeVersion = {
    /**
     * - The Android Debug Bridge version number
     */
    version: string;
};
export type Version = {
    /**
     * This version number might not be
     * be present for older ADB releases.
     */
    binary: BinaryVersion | null;
    bridge: BridgeVersion;
};
export type RootResult = {
    /**
     * True if the call to root/unroot was successful
     */
    isSuccessful: boolean;
    /**
     * True if the device was already rooted
     */
    wasAlreadyRooted: boolean;
};
export type SystemCalls = typeof systemCallMethods;
declare namespace systemCallMethods {
    /**
     * Retrieve full path to the given binary.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} binaryName - The name of the binary.
     * @return {Promise<string>} Full path to the given binary including current SDK root.
     */
    function getSdkBinaryPath(this: import("../adb.js").ADB, binaryName: string): Promise<string>;
    let getBinaryNameForOS: ((binaryName: any) => string) & _.MemoizedFunction;
    /**
     * Retrieve full path to the given binary and caches it into `binaries`
     * property of the current ADB instance.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} binaryName - Simple name of a binary file.
     * @return {Promise<string>} Full path to the given binary. The method tries
     *                  to enumerate all the known locations where the binary
     *                  might be located and stops the search as soon as the first
     *                  match is found on the local file system.
     * @throws {Error} If the binary with given name is not present at any
     *                 of known locations or Android SDK is not installed on the
     *                 local file system.
     */
    function getBinaryFromSdkRoot(this: import("../adb.js").ADB, binaryName: string): Promise<string>;
    /**
     * Retrieve full path to a binary file using the standard system lookup tool.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} binaryName - The name of the binary.
     * @return {Promise<string>} Full path to the binary received from 'which'/'where'
     *                  output.
     * @throws {Error} If lookup tool returns non-zero return code.
     */
    function getBinaryFromPath(this: import("../adb.js").ADB, binaryName: string): Promise<string>;
    /**
     * @typedef {Object} ConnectedDevicesOptions
     * @property {boolean} [verbose] - Whether to get long output, which includes extra properties in each device.
     * Akin to running `adb devices -l`.
     */
    /**
     * @typedef {Object} Device
     * @property {string} udid - The device udid.
     * @property {string} state - Current device state, as it is visible in
     *                            _adb devices -l_ output.
     * @property {number} [port]
     */
    /**
     * @typedef {Device} VerboseDevice Additional properties returned when `verbose` is true.
     * @property {string} product - The product codename of the device, such as "razor".
     * @property {string} model - The model name of the device, such as "Nexus_7".
     * @property {string} device - The device codename, such as "flow".
     * @property {?string} usb - Represents the USB port the device is connected to, such as "1-1".
     * @property {?string} transport_id - The Transport ID for the device, such as "1".
     */
    /**
     * Retrieve the list of devices visible to adb.
     *
     * @this {import('../adb.js').ADB}
     * @param {ConnectedDevicesOptions} [opts={}] - Additional options mapping.
     * @return {Promise<Device[]>} The list of devices or an empty list if
     *                          no devices are connected.
     * @throws {Error} If there was an error while listing devices.
     */
    function getConnectedDevices(this: import("../adb.js").ADB, opts?: ConnectedDevicesOptions | undefined): Promise<Device[]>;
    /**
     * Retrieve the list of devices visible to adb within the given timeout.
     *
     * @this {import('../adb.js').ADB}
     * @param {number} timeoutMs - The maximum number of milliseconds to get at least
     *                             one list item.
     * @return {Promise<Device[]>} The list of connected devices.
     * @throws {Error} If no connected devices can be detected within the given timeout.
     */
    function getDevicesWithRetry(this: import("../adb.js").ADB, timeoutMs?: number): Promise<Device[]>;
    /**
     * Kick current connection from host/device side and make it reconnect
     *
     * @this {import('../adb.js').ADB}
     * @param {string} [target=offline] One of possible targets to reconnect:
     * offline, device or null
     * Providing `null` will cause reconnection to happen from the host side.
     *
     * @throws {Error} If either ADB version is too old and does not support this
     * command or there was a failure during reconnect.
     */
    function reconnect(this: import("../adb.js").ADB, target?: string | undefined): Promise<void>;
    /**
     * Restart adb server, unless _this.suppressKillServer_ property is true.
     *
     * @this {import('../adb.js').ADB}
     */
    function restartAdb(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Kill adb server.
     * @this {import('../adb.js').ADB}
     */
    function killServer(this: import("../adb.js").ADB): Promise<void>;
    let resetTelnetAuthToken: (() => Promise<boolean>) & _.MemoizedFunction;
    /**
     * Execute the given emulator command using _adb emu_ tool.
     *
     * @this {import('../adb.js').ADB}
     * @param {string[]} cmd - The array of rest command line parameters.
     */
    function adbExecEmu(this: import("../adb.js").ADB, cmd: string[]): Promise<void>;
    let EXEC_OUTPUT_FORMAT: {
        STDOUT: "stdout";
        FULL: "full";
    };
    /**
     * @typedef {Object} ExecResult
     * @property {string} stdout The stdout received from exec
     * @property {string} stderr The stderr received from exec
     */
    /**
     * @typedef {Object} SpecialAdbExecOptions
     * @property {boolean} [exclusive]
     */
    /**
     * @typedef {Object} ShellExecOptions
     * @property {string} [timeoutCapName] - the name of the corresponding Appium's timeout capability
     * (used in the error messages).
     * @property {number} [timeout] - command execution timeout.
     * @property {boolean} [privileged=false] - Whether to run the given command as root.
     * @property {ExecOutputFormat} [outputFormat='stdout'] - Whether response should include full exec output or just stdout.
     * Potential values are full or stdout.
     *
     * All other properties are the same as for `exec` call from {@link https://github.com/appium/node-teen_process}
     * module
     */
    /**
     * @typedef {{outputFormat: 'full'}} TFullOutputOption
     */
    /**
     * Execute the given adb command.
     *
     * @template {import('teen_process').TeenProcessExecOptions & ShellExecOptions & SpecialAdbExecOptions} TExecOpts
     * @this {import('../adb.js').ADB}
     * @param {string|string[]} cmd - The array of rest command line parameters
     *                      or a single string parameter.
     * @param {TExecOpts} [opts] Additional options mapping. See
     * {@link https://github.com/appium/node-teen_process}
     * for more details.
     * You can also set the additional `exclusive` param
     * to `true` that assures no other parallel adb commands
     * are going to be executed while the current one is running
     * You can set the `outputFormat` param to `stdout` to receive just the stdout
     * output (default) or `full` to receive the stdout and stderr response from a
     * command with a zero exit code
     * @return {Promise<TExecOpts extends TFullOutputOption ? import('teen_process').TeenProcessExecResult : string>}
     * Command's stdout or an object containing stdout and stderr.
     * @throws {Error} If the command returned non-zero exit code.
     */
    function adbExec<TExecOpts extends import("teen_process").TeenProcessExecOptions & ShellExecOptions & SpecialAdbExecOptions>(this: import("../adb.js").ADB, cmd: string | string[], opts?: TExecOpts | undefined): Promise<TExecOpts extends TFullOutputOption ? import("teen_process").TeenProcessExecResult<any> : string>;
    /**
     * Execute the given command using _adb shell_ prefix.
     *
     * @this {import('../adb.js').ADB}
     * @template {ShellExecOptions} TShellExecOpts
     * @param {string|string[]} cmd - The array of rest command line parameters or a single
     *                                      string parameter.
     * @param {TShellExecOpts} [opts] - Additional options mapping.
     * @return {Promise<TShellExecOpts extends TFullOutputOption ? import('teen_process').TeenProcessExecResult : string>}
     * Command's stdout.
     * @throws {Error} If the command returned non-zero exit code.
     */
    function shell<TShellExecOpts extends ShellExecOptions>(this: import("../adb.js").ADB, cmd: string | string[], opts?: TShellExecOpts | undefined): Promise<TShellExecOpts extends TFullOutputOption ? import("teen_process").TeenProcessExecResult<any> : string>;
    /**
     *
     * @this {import('../adb.js').ADB}
     * @param {string[]} [args=[]]
     * @returns {import('teen_process').SubProcess}
     */
    function createSubProcess(this: import("../adb.js").ADB, args?: string[] | undefined): import("teen_process").SubProcess;
    /**
     * Retrieve the current adb port.
     * @todo can probably deprecate this now that the logic is just to read this.adbPort
     *
     * @this {import('../adb.js').ADB}
     * @return {number} The current adb port number.
     */
    function getAdbServerPort(this: import("../adb.js").ADB): number;
    /**
     * Retrieve the current emulator port from _adb devives_ output.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<number>} The current emulator port.
     * @throws {Error} If there are no connected devices.
     */
    function getEmulatorPort(this: import("../adb.js").ADB): Promise<number>;
    /**
     * Retrieve the current emulator port by parsing emulator name string.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} emStr - Emulator name string.
     * @return {number|false} Either the current emulator port or
     * _false_ if port number cannot be parsed.
     */
    function getPortFromEmulatorString(this: import("../adb.js").ADB, emStr: string): number | false;
    /**
     * Retrieve the list of currently connected emulators.
     *
     * @this {import('../adb.js').ADB}
     * @param {ConnectedDevicesOptions} [opts={}] - Additional options mapping.
     * @return {Promise<Device[]>} The list of connected devices.
     */
    function getConnectedEmulators(this: import("../adb.js").ADB, opts?: ConnectedDevicesOptions | undefined): Promise<Device[]>;
    /**
     * Set _emulatorPort_ property of the current class.
     *
     * @this {import('../adb.js').ADB}
     * @param {number} emPort - The emulator port to be set.
     */
    function setEmulatorPort(this: import("../adb.js").ADB, emPort: number): void;
    /**
     * Set the identifier of the current device (_this.curDeviceId_).
     *
     * @this {import('../adb.js').ADB}
     * @param {string} deviceId - The device identifier.
     */
    function setDeviceId(this: import("../adb.js").ADB, deviceId: string): void;
    /**
     * Set the the current device object.
     *
     * @this {import('../adb.js').ADB}
     * @param {Device} deviceObj - The device object to be set.
     */
    function setDevice(this: import("../adb.js").ADB, deviceObj: Device): void;
    /**
     * Get the object for the currently running emulator.
     * !!! This method has a side effect - it implicitly changes the
     * `deviceId` (only if AVD with a matching name is found)
     * and `emulatorPort` instance properties.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} avdName - Emulator name.
     * @return {Promise<Device|null>} Currently running emulator or _null_.
     */
    function getRunningAVD(this: import("../adb.js").ADB, avdName: string): Promise<Device | null>;
    /**
     * Get the object for the currently running emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} avdName - Emulator name.
     * @param {number} [timeoutMs=20000] - The maximum number of milliseconds
     *                                     to wait until at least one running AVD object
     *                                     is detected.
     * @return {Promise<Device|null>} Currently running emulator or _null_.
     * @throws {Error} If no device has been detected within the timeout.
     */
    function getRunningAVDWithRetry(this: import("../adb.js").ADB, avdName: string, timeoutMs?: number | undefined): Promise<Device | null>;
    /**
     * Shutdown all running emulators by killing their processes.
     *
     * @this {import('../adb.js').ADB}
     * @throws {Error} If killing tool returned non-zero return code.
     */
    function killAllEmulators(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Kill emulator with the given name. No error
     * is thrown is given avd does not exist/is not running.
     *
     * @this {import('../adb.js').ADB}
     * @param {string?} [avdName=null] - The name of the emulator to be killed. If empty,
     *                            the current emulator will be killed.
     * @param {number} [timeout=60000] - The amount of time to wait before throwing
     *                                    an exception about unsuccessful killing
     * @return {Promise<boolean>} - True if the emulator was killed, false otherwise.
     * @throws {Error} if there was a failure by killing the emulator
     */
    function killEmulator(this: import("../adb.js").ADB, avdName?: string | null | undefined, timeout?: number | undefined): Promise<boolean>;
    /**
     * @typedef {Object} AvdLaunchOptions
     * @property {string|string[]} [args] Additional emulator command line arguments
     * @property {Object} [env] Additional emulator environment variables
     * @property {string} [language] Emulator system language
     * @property {string} [country] Emulator system country
     * @property {number} [launchTimeout=60000] Emulator startup timeout in milliseconds
     * @property {number} [readyTimeout=60000] The maximum period of time to wait until Emulator
     * is ready for usage in milliseconds
     * @property {number} [retryTimes=1] The maximum number of startup retries
     */
    /**
     * Start an emulator with given parameters and wait until it is fully started.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} avdName - The name of an existing emulator.
     * @param {AvdLaunchOptions} [opts={}]
     * @returns {Promise<SubProcess>} Emulator subprocess instance
     * @throws {Error} If the emulator fails to start within the given timeout.
     */
    function launchAVD(this: import("../adb.js").ADB, avdName: string, opts?: AvdLaunchOptions | undefined): Promise<SubProcess>;
    let getVersion: (() => Promise<{
        binary: {
            version: semver.SemVer | null;
            build: number;
        };
        bridge: {
            version: semver.SemVer | null;
        };
    }>) & _.MemoizedFunction;
    /**
     * Check if the current emulator is ready to accept further commands (booting completed).
     *
     * @this {import('../adb.js').ADB}
     * @param {number} [timeoutMs=20000] - The maximum number of milliseconds to wait.
     * @returns {Promise<void>}
     * @throws {Error} If the emulator is not ready within the given timeout.
     */
    function waitForEmulatorReady(this: import("../adb.js").ADB, timeoutMs?: number | undefined): Promise<void>;
    /**
     * Check if the current device is ready to accept further commands (booting completed).
     *
     * @this {import('../adb.js').ADB}
     * @param {number} [appDeviceReadyTimeout=30] - The maximum number of seconds to wait.
     * @throws {Error} If the device is not ready within the given timeout.
     */
    function waitForDevice(this: import("../adb.js").ADB, appDeviceReadyTimeout?: number | undefined): Promise<void>;
    /**
     * Reboot the current device and wait until it is completed.
     *
     * @this {import('../adb.js').ADB}
     * @param {number} [retries=DEFAULT_ADB_REBOOT_RETRIES] - The maximum number of reboot retries.
     * @throws {Error} If the device failed to reboot and number of retries is exceeded.
     */
    function reboot(this: import("../adb.js").ADB, retries?: number | undefined): Promise<void>;
    /**
     * @typedef {Object} RootResult
     * @property {boolean} isSuccessful True if the call to root/unroot was successful
     * @property {boolean} wasAlreadyRooted True if the device was already rooted
     */
    /**
     * Switch adb server root privileges.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} isElevated - Should we elevate to to root or unroot? (default true)
     * @return {Promise<RootResult>}
     */
    function changeUserPrivileges(this: import("../adb.js").ADB, isElevated: boolean): Promise<RootResult>;
    /**
     * Switch adb server to root mode
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<RootResult>}
     */
    function root(this: import("../adb.js").ADB): Promise<RootResult>;
    /**
     * Switch adb server to non-root mode.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<RootResult>}
     */
    function unroot(this: import("../adb.js").ADB): Promise<RootResult>;
    /**
     * Checks whether the current user is root
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<boolean>} True if the user is root
     * @throws {Error} if there was an error while identifying
     * the user.
     */
    function isRoot(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Verify whether a remote path exists on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} remotePath - The remote path to verify.
     * @return {Promise<boolean>} True if the given path exists on the device.
     */
    function fileExists(this: import("../adb.js").ADB, remotePath: string): Promise<boolean>;
    /**
     * Get the output of _ls_ command on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} remotePath - The remote path (the first argument to the _ls_ command).
     * @param {string[]} [opts] - Additional _ls_ options.
     * @return {Promise<string[]>} The _ls_ output as an array of split lines.
     *                          An empty array is returned of the given _remotePath_
     *                          does not exist.
     */
    function ls(this: import("../adb.js").ADB, remotePath: string, opts?: string[] | undefined): Promise<string[]>;
    /**
     * Get the size of the particular file located on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} remotePath - The remote path to the file.
     * @return {Promise<number>} File size in bytes.
     * @throws {Error} If there was an error while getting the size of the given file.
     */
    function fileSize(this: import("../adb.js").ADB, remotePath: string): Promise<number>;
    /**
     * Installs the given certificate on a rooted real device or
     * an emulator. The emulator must be executed with `-writable-system`
     * command line option and adb daemon should be running in root
     * mode for this method to work properly. The method also requires
     * openssl tool to be available on the destination system.
     * Read https://github.com/appium/appium/issues/10964
     * for more details on this topic
     *
     * @this {import('../adb.js').ADB}
     * @param {Buffer|string} cert - base64-decoded content of the actual certificate
     * represented as a string or a buffer
     * @throws {Error} If openssl tool is not available on the destination system
     * or if there was an error while installing the certificate
     */
    function installMitmCertificate(this: import("../adb.js").ADB, cert: Buffer | string): Promise<void>;
    /**
     * Verifies if the given root certificate is already installed on the device.
     *
     * @this {import('../adb.js').ADB}
     * @param {Buffer|string} cert - base64-decoded content of the actual certificate
     * represented as a string or a buffer
     * @throws {Error} If openssl tool is not available on the destination system
     * or if there was an error while checking the certificate
     * @returns {Promise<boolean>} true if the given certificate is already installed
     */
    function isMitmCertificateInstalled(this: import("../adb.js").ADB, cert: Buffer | string): Promise<boolean>;
}
import { DEFAULT_ADB_EXEC_TIMEOUT } from '../helpers';
/**
 * Retrieve full path to the given binary.
 * This method does not have cache.
 *
 * @param {string} binaryName - Simple name of a binary file.
 *                              e.g. 'adb', 'android'
 * @return {Promise<string>} Full path to the given binary. The method tries
 *                  to enumerate all the known locations where the binary
 *                  might be located and stops the search as soon as the first
 *                  match is found on the local file system.
 *                  e.g. '/Path/To/Android/sdk/platform-tools/adb'
 * @throws {Error} If the binary with given name is not present at any
 *                 of known locations or Android SDK is not installed on the
 *                 local file system.
 */
export function getAndroidBinaryPath(binaryName: string): Promise<string>;
import _ from 'lodash';
import { SubProcess } from 'teen_process';
import semver from 'semver';
export { DEFAULT_ADB_EXEC_TIMEOUT };
//# sourceMappingURL=system-calls.d.ts.map