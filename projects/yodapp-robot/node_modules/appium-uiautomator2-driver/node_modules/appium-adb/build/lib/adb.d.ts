import { getAndroidBinaryPath } from './tools';
import { getSdkRootFromEnv } from './helpers';
import type { ADBOptions, ADBExecutable } from './options';
import type { LogcatOpts } from './logcat';
import type { LRUCache } from 'lru-cache';
declare const DEFAULT_ADB_PORT = 5037;
export declare const DEFAULT_OPTS: {
    readonly sdkRoot: string | undefined;
    readonly executable: {
        readonly path: "adb";
        readonly defaultArgs: readonly [];
    };
    readonly tmpDir: string;
    readonly binaries: {};
    readonly adbPort: 5037;
    readonly adbExecTimeout: 20000;
    readonly remoteAppsCacheLimit: 10;
    readonly allowOfflineDevices: false;
    readonly allowDelayAdb: true;
};
export declare class ADB {
    adbHost?: string;
    adbPort?: number;
    _apiLevel: number | undefined;
    _logcatStartupParams: LogcatOpts | undefined;
    _doesPsSupportAOption: boolean | undefined;
    _isPgrepAvailable: boolean | undefined;
    _canPgrepUseFullCmdLineSearch: boolean | undefined;
    _isPidofAvailable: boolean | undefined;
    _memoizedFeatures: (() => Promise<string>) | undefined;
    _areExtendedLsOptionsSupported: boolean | undefined;
    remoteAppsCache: LRUCache<string, string> | undefined;
    _isLockManagementSupported: boolean | undefined;
    executable: ADBExecutable;
    constructor(opts?: ADBOptions);
    /**
     * Create a new instance of `ADB` that inherits configuration from this `ADB` instance.
     * This avoids the need to call `ADB.createADB()` multiple times.
     * @param opts - Additional options mapping to pass to the `ADB` constructor.
     * @returns The resulting class instance.
     */
    clone(opts?: ADBOptions): ADB;
    static createADB(opts?: ADBOptions): Promise<ADB>;
}
export { DEFAULT_ADB_PORT, getAndroidBinaryPath, getSdkRootFromEnv };
//# sourceMappingURL=adb.d.ts.map