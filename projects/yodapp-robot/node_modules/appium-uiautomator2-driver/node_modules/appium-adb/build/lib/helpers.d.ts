/**
 * Check the current device power state to determine if it is locked
 *
 * @param {string} dumpsys The `adb shell dumpsys power` output
 * @returns {boolean} True if lock screen is shown
 */
export function isInDozingMode(dumpsys: string): boolean;
export type PlatformInfo = {
    /**
     * - The platform name, for example `android-24`
     *   or `null` if it cannot be found
     */
    platform: string | null;
    /**
     * - Full path to the platform SDK folder
     *   or `null` if it cannot be found
     */
    platformPath: string | null;
};
export type InstallOptions = {
    /**
     * - Set to true in order to allow test
     *    packages installation.
     */
    allowTestPackages?: boolean | undefined;
    /**
     * - Set to true to install the app on sdcard
     *    instead of the device memory.
     */
    useSdcard?: boolean | undefined;
    /**
     * - Set to true in order to grant all the
     *    permissions requested in the application's manifest
     *    automatically after the installation is completed
     *    under Android 6+.
     */
    grantPermissions?: boolean | undefined;
    /**
     * - Set it to false if you don't want
     *    the application to be upgraded/reinstalled
     *    if it is already present on the device.
     */
    replace?: boolean | undefined;
    /**
     * - Install apks partially. It is used for 'install-multiple'.
     *   https://android.stackexchange.com/questions/111064/what-is-a-partial-application-install-via-adb
     */
    partialInstall?: boolean | undefined;
};
export type ManifestInfo = {
    /**
     * - The application identifier
     */
    pkg: string;
    /**
     * - The name of the main package activity
     */
    activity?: string | undefined;
    /**
     * - The version code number (might be `NaN`)
     */
    versionCode: number | null;
    /**
     * - The version name (might be `null`)
     */
    versionName: string | null;
};
/**
 * @typedef {Object} PlatformInfo
 * @property {string?} platform - The platform name, for example `android-24`
 *                                or `null` if it cannot be found
 * @property {string?} platformPath - Full path to the platform SDK folder
 *                                    or `null` if it cannot be found
 */
/**
 * Retrieve the path to the recent installed Android platform.
 *
 * @param {string} sdkRoot
 * @return {Promise<PlatformInfo>} The resulting path to the newest installed platform.
 */
export function getAndroidPlatformAndPath(sdkRoot: string): Promise<PlatformInfo>;
/**
 * @param {string} zipPath
 * @param {string} dstRoot
 */
export function unzipFile(zipPath: string, dstRoot?: string): Promise<void>;
/**
 * @param {string} stdout
 * @returns {string[]}
 */
export function getIMEListFromOutput(stdout: string): string[];
/** @type {() => Promise<string>} */
export const getJavaForOs: () => Promise<string>;
/**
 * Checks mShowingLockscreen or mDreamingLockscreen in dumpsys output to determine
 * if lock screen is showing
 *
 * A note: `adb shell dumpsys trust` performs better while detecting the locked screen state
 * in comparison to `adb dumpsys window` output parsing.
 * But the trust command does not work for `Swipe` unlock pattern.
 *
 * In some Android devices (Probably around Android 10+), `mShowingLockscreen` and `mDreamingLockscreen`
 * do not work to detect lock status. Instead, keyguard preferences helps to detect the lock condition.
 * Some devices such as Android TV do not have keyguard, so we should keep
 * screen condition as this primary method.
 *
 * @param {string} dumpsys - The output of dumpsys window command.
 * @return {boolean} True if lock screen is showing.
 */
export function isShowingLockscreen(dumpsys: string): boolean;
export function isCurrentFocusOnKeyguard(dumpsys: any): boolean;
export function getSurfaceOrientation(dumpsys: any): number | null;
export function isScreenOnFully(dumpsys: any): boolean;
/**
 * Builds command line representation for the given
 * application startup options
 *
 * @param {Record<string, any>} startAppOptions - Application options mapping
 * @param {number} apiLevel - The actual OS API level
 * @returns {string[]} The actual command line array
 */
export function buildStartCmd(startAppOptions: Record<string, any>, apiLevel: number): string[];
/** @type {() => Promise<string>} */
export const getJavaHome: () => Promise<string>;
/** @type {() => Promise<{major: number, minor: number, build: number}?>} */
export const getSdkToolsVersion: () => Promise<{
    major: number;
    minor: number;
    build: number;
} | null>;
/**
 * Get the absolute path to apksigner tool
 *
 * @param {Object} sysHelpers - An instance containing systemCallMethods helper methods
 * @returns {Promise<string>} An absolute path to apksigner tool.
 * @throws {Error} If the tool is not present on the local file system.
 */
export function getApksignerForOs(sysHelpers: any): Promise<string>;
/**
 * Retrieves full paths to all 'build-tools' subfolders under the particular
 * SDK root folder
 *
 * @type {(sdkRoot: string) => Promise<string[]>}
 */
export const getBuildToolsDirs: (sdkRoot: string) => Promise<string[]>;
/**
 * Get the absolute path to apkanalyzer tool.
 * https://developer.android.com/studio/command-line/apkanalyzer.html
 *
 * @param {Object} sysHelpers - An instance containing systemCallMethods helper methods
 * @returns {Promise<string>} An absolute path to apkanalyzer tool.
 * @throws {Error} If the tool is not present on the local file system.
 */
export function getApkanalyzerForOs(sysHelpers: any): Promise<string>;
/** @type {() => Promise<string>} */
export const getOpenSslForOs: () => Promise<string>;
/**
 * Retrieves the list of permission names encoded in `dumpsys package` command output.
 *
 * @param {string} dumpsysOutput - The actual command output.
 * @param {string[]} groupNames - The list of group names to list permissions for.
 * @param {boolean?} [grantedState=null] - The expected state of `granted` attribute to filter with.
 *  No filtering is done if the parameter is not set.
 * @returns {string[]} The list of matched permission names or an empty list if no matches were found.
 */
export function extractMatchingPermissions(dumpsysOutput: string, groupNames: string[], grantedState?: boolean | null | undefined): string[];
export const APKS_EXTENSION: ".apks";
export const APK_INSTALL_TIMEOUT: 60000;
export const APKS_INSTALL_TIMEOUT: number;
/**
 * @typedef {Object} InstallOptions
 * @property {boolean} [allowTestPackages=false] - Set to true in order to allow test
 *                                                 packages installation.
 * @property {boolean} [useSdcard=false] - Set to true to install the app on sdcard
 *                                         instead of the device memory.
 * @property {boolean} [grantPermissions=false] - Set to true in order to grant all the
 *                                                permissions requested in the application's manifest
 *                                                automatically after the installation is completed
 *                                                under Android 6+.
 * @property {boolean} [replace=true] - Set it to false if you don't want
 *                                      the application to be upgraded/reinstalled
 *                                      if it is already present on the device.
 * @property {boolean} [partialInstall=false] - Install apks partially. It is used for 'install-multiple'.
 *                                             https://android.stackexchange.com/questions/111064/what-is-a-partial-application-install-via-adb
 */
/**
 * Transforms given options into the list of `adb install.install-multiple` command arguments
 *
 * @param {number} apiLevel - The current API level
 * @param {InstallOptions} [options={}] - The options mapping to transform
 * @returns {string[]} The array of arguments
 */
export function buildInstallArgs(apiLevel: number, options?: InstallOptions | undefined): string[];
export const APK_EXTENSION: ".apk";
export const DEFAULT_ADB_EXEC_TIMEOUT: 20000;
/**
 * @typedef {Object} ManifestInfo
 * @property {string} pkg - The application identifier
 * @property {string} [activity] - The name of the main package activity
 * @property {?number} versionCode - The version code number (might be `NaN`)
 * @property {?string} versionName - The version name (might be `null`)
 */
/**
 * Perform parsing of the manifest object in order
 * to extract some vital values from it
 *
 * @param {Record<string, any>} manifest The manifest content formatted as JSON
 * See https://www.npmjs.com/package/@devicefarmer/adbkit-apkreader for detailed format description
 * @returns {ManifestInfo}
 */
export function parseManifest(manifest: Record<string, any>): ManifestInfo;
/**
 * Parses apk strings from aapt tool output
 *
 * @param {string} rawOutput The actual tool output
 * @param {string} configMarker The config marker. Usually
 * a language abbreviation or `(default)`
 * @returns {Object} Strings ids to values mapping. Plural
 * values are represented as arrays. If no config found for the
 * given marker then an empty mapping is returned.
 */
export function parseAaptStrings(rawOutput: string, configMarker: string): any;
/**
 * Parses apk strings from aapt2 tool output
 *
 * @param {string} rawOutput The actual tool output
 * @param {string} configMarker The config marker. Usually
 * a language abbreviation or an empty string for the default one
 * @returns {Object} Strings ids to values mapping. Plural
 * values are represented as arrays. If no config found for the
 * given marker then an empty mapping is returned.
 */
export function parseAapt2Strings(rawOutput: string, configMarker: string): any;
/**
 * Formats the config marker, which is then passed to parse.. methods
 * to make it compatible with resource formats generated by aapt(2) tool
 *
 * @param {Function} configsGetter The function whose result is a list
 * of apk configs
 * @param {string?} desiredMarker The desired config marker value
 * @param {string} defaultMarker The default config marker value
 * @return {Promise<string>} The formatted config marker
 */
export function formatConfigMarker(configsGetter: Function, desiredMarker: string | null, defaultMarker: string): Promise<string>;
/**
 * Unsigns the given apk by removing the
 * META-INF folder recursively from the archive.
 * !!! The function overwrites the given apk after successful unsigning !!!
 *
 * @param {string} apkPath The path to the apk
 * @returns {Promise<boolean>} `true` if the apk has been successfully
 * unsigned and overwritten
 * @throws {Error} if there was an error during the unsign operation
 */
export function unsignApk(apkPath: string): Promise<boolean>;
/**
 * Transforms the given language and country abbreviations
 * to AVD arguments array
 *
 * @param {?string} language Language name, for example 'fr'
 * @param {?string} country Country name, for example 'CA'
 * @returns {Array<string>} The generated arguments. The
 * resulting array might be empty if both arguments are empty
 */
export function toAvdLocaleArgs(language: string | null, country: string | null): Array<string>;
/**
 * Retrieves the actual path to SDK root folder
 *
 * @param {string?} [customRoot]
 * @return {Promise<string>} The full path to the SDK root folder
 * @throws {Error} If either the corresponding env variable is unset or is
 * pointing to an invalid file system entry
 */
export function requireSdkRoot(customRoot?: string | null | undefined): Promise<string>;
/**
 * Retrieves the actual path to SDK root folder from the system environment
 *
 * @return {string|undefined} The full path to the SDK root folder
 */
export function getSdkRootFromEnv(): string | undefined;
/**
 * Retrieves the full path to the Android preferences root
 *
 * @returns {Promise<string?>} The full path to the folder or `null` if the folder cannot be found
 */
export function getAndroidPrefsRoot(): Promise<string | null>;
/**
 * Check if a path exists on the filesystem and is a directory
 *
 * @param {string} location The full path to the directory
 * @returns {Promise<boolean>}
 */
export function dirExists(location: string): Promise<boolean>;
/**
 * Escapes special characters in command line arguments.
 * This is needed to avoid possible issues with how system `spawn`
 * call handles them.
 * See https://discuss.appium.io/t/how-to-modify-wd-proxy-and-uiautomator2-source-code-to-support-unicode/33466
 * for more details.
 *
 * @param {string} arg Non-escaped argument string
 * @returns The escaped argument
 */
export function escapeShellArg(arg: string): string;
/**
 * Parses the name of launchable package activity
 * from dumpsys output.
 *
 * @param {string} dumpsys the actual dumpsys output
 * @returns {string[]} Either the fully qualified
 * activity name as a single list item or an empty list if nothing could be parsed.
 * In Android 6 and older there is no reliable way to determine
 * the category name for the given activity, so this API just
 * returns all activity names belonging to 'android.intent.action.MAIN'
 * with the expectation that the app manifest could be parsed next
 * in order to determine category names for these.
 */
export function parseLaunchableActivityNames(dumpsys: string): string[];
/**
 * Check if the given string is a valid component name
 *
 * @param {string} classString The string to verify
 * @return {RegExpExecArray?} The result of Regexp.exec operation
 * or _null_ if no matches are found
 */
export function matchComponentName(classString: string): RegExpExecArray | null;
/**
 * Calculates the absolsute path to the given resource
 *
 * @param {string} relPath Relative path to the resource starting from the current module root
 * @returns {Promise<string>} The full path to the resource
 * @throws {Error} If the absolute resource path cannot be determined
 */
export const getResourcePath: ((relPath: any) => Promise<string>) & _.MemoizedFunction;
import _ from 'lodash';
//# sourceMappingURL=helpers.d.ts.map