export default methods;
export type ResolveActivityOptions = {
    /**
     * Whether to prefer `cmd` tool usage for
     * launchable activity name detection. It might be useful to disable it if
     * `cmd package resolve-activity` returns 'android/com.android.internal.app.ResolverActivity',
     * which means the app has no default handler set in system settings.
     * See https://github.com/appium/appium/issues/17128 for more details.
     * This option has no effect if the target Android version is below 24 as there
     * the corresponding `cmd` subcommand is not implemented and dumpsys usage is the only
     * possible way to detect the launchable activity name.
     */
    preferCmd?: boolean | undefined;
};
/**
 * Listener function, which accepts one argument.
 *
 * The argument is a log record object with `timestamp`, `level` and `message` properties.
 */
export type LogcatListener = (record: LogcatRecord) => any;
export type LogcatRecord = {
    timestamp: number;
    level: string;
    message: string;
};
export type SetPropOpts = {
    /**
     * - Do we run setProp as a privileged command? Default true.
     */
    privileged?: boolean | undefined;
};
export type ScreenrecordOptions = {
    /**
     * - The format is widthxheight.
     * The default value is the device's native display resolution (if supported),
     * 1280x720 if not. For best results,
     * use a size supported by your device's Advanced Video Coding (AVC) encoder.
     * For example, "1280x720"
     */
    videoSize?: string | undefined;
    /**
     * - Set it to `true` in order to display additional information on the video overlay,
     *   such as a timestamp, that is helpful in videos captured to illustrate bugs.
     *   This option is only supported since API level 27 (Android P).
     */
    bugReport?: boolean | undefined;
    /**
     * - The maximum recording time, in seconds.
     *   The default (and maximum) value is 180 (3 minutes).
     */
    timeLimit?: string | number | undefined;
    /**
     * - The video bit rate for the video, in megabits per second.
     * The default value is 4. You can increase the bit rate to improve video quality,
     * but doing so results in larger movie files.
     */
    bitRate?: string | number | undefined;
};
export type ADBCommands = typeof methods;
declare namespace methods {
    /**
     * Creates chunks for the given arguments and executes them in `adb shell`.
     * This is faster than calling `adb shell` separately for each arg, however
     * there is a limit for a maximum length of a single adb command. that is why
     * we need all this complicated logic.
     *
     * @this {import('../adb.js').ADB}
     * @param {(x: string) => string[]} argTransformer A function, that receives single argument
     * from the `args` array and transforms it into a shell command. The result
     * of the function must be an array, where each item is a part of a single command.
     * The last item of the array could be ';'. If this is not a semicolon then it is going to
     * be added automatically.
     * @param {string[]} args Array of argument values to create chunks for
     * @throws {Error} If any of the chunks returns non-zero exit code after being executed
     */
    function shellChunks(this: import("../adb.js").ADB, argTransformer: (x: string) => string[], args: string[]): Promise<void>;
    /**
     * Get the path to adb executable amd assign it
     * to this.executable.path and this.binaries.adb properties.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<import('../adb.js').ADB>} ADB instance.
     */
    function getAdbWithCorrectAdbPath(this: import("../adb.js").ADB): Promise<import("../adb.js").ADB>;
    /**
     * Get the full path to aapt tool and assign it to
     * this.binaries.aapt property
     * @this {import('../adb.js').ADB}
     */
    function initAapt(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Get the full path to aapt2 tool and assign it to
     * this.binaries.aapt2 property
     * @this {import('../adb.js').ADB}
     */
    function initAapt2(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Get the full path to zipalign tool and assign it to
     * this.binaries.zipalign property
     * @this {import('../adb.js').ADB}
     */
    function initZipAlign(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Get the full path to bundletool binary and assign it to
     * this.binaries.bundletool property
     * @this {import('../adb.js').ADB}
     */
    function initBundletool(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Retrieve the API level of the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<number>} The API level as integer number, for example 21 for
     *                  Android Lollipop. The result of this method is cached, so all the further
     * calls return the same value as the first one.
     */
    function getApiLevel(this: import("../adb.js").ADB): Promise<number>;
    /**
     * Retrieve the platform version of the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} The platform version as a string, for example '5.0' for
     * Android Lollipop.
     */
    function getPlatformVersion(this: import("../adb.js").ADB): Promise<string>;
    /**
     * Verify whether a device is connected.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<boolean>} True if at least one device is visible to adb.
     */
    function isDeviceConnected(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Recursively create a new folder on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} remotePath - The new path to be created.
     * @return {Promise<string>} mkdir command output.
     */
    function mkdir(this: import("../adb.js").ADB, remotePath: string): Promise<string>;
    /**
     * Verify whether the given argument is a
     * valid class name.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} classString - The actual class name to be verified.
     * @return {boolean} The result of Regexp.exec operation
     * or _null_ if no matches are found.
     */
    function isValidClass(this: import("../adb.js").ADB, classString: string): boolean;
    /**
     * @typedef {Object} ResolveActivityOptions
     * @property {boolean} [preferCmd=true] Whether to prefer `cmd` tool usage for
     * launchable activity name detection. It might be useful to disable it if
     * `cmd package resolve-activity` returns 'android/com.android.internal.app.ResolverActivity',
     * which means the app has no default handler set in system settings.
     * See https://github.com/appium/appium/issues/17128 for more details.
     * This option has no effect if the target Android version is below 24 as there
     * the corresponding `cmd` subcommand is not implemented and dumpsys usage is the only
     * possible way to detect the launchable activity name.
     */
    /**
     * Fetches the fully qualified name of the launchable activity for the
     * given package. It is expected the package is already installed on
     * the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The target package identifier
     * @param {ResolveActivityOptions} opts
     * @return {Promise<string>} Fully qualified name of the launchable activity
     * @throws {Error} If there was an error while resolving the activity name
     */
    function resolveLaunchableActivity(this: import("../adb.js").ADB, pkg: string, opts?: ResolveActivityOptions): Promise<string>;
    /**
     * Force application to stop on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be stopped.
     * @return {Promise<string>} The output of the corresponding adb command.
     */
    function forceStop(this: import("../adb.js").ADB, pkg: string): Promise<string>;
    /**
     * Kill application
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be stopped.
     * @return {Promise<string>} The output of the corresponding adb command.
     */
    function killPackage(this: import("../adb.js").ADB, pkg: string): Promise<string>;
    /**
     * Clear the user data of the particular application on the device
     * under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be cleared.
     * @return {Promise<string>} The output of the corresponding adb command.
     */
    function clear(this: import("../adb.js").ADB, pkg: string): Promise<string>;
    /**
     * Grant all permissions requested by the particular package.
     * This method is only useful on Android 6.0+ and for applications
     * that support components-based permissions setting.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be processed.
     * @param {string} [apk] - The path to the actual apk file.
     * @throws {Error} If there was an error while granting permissions
     */
    function grantAllPermissions(this: import("../adb.js").ADB, pkg: string, apk?: string | undefined): Promise<void>;
    /**
     * Grant multiple permissions for the particular package.
     * This call is more performant than `grantPermission` one, since it combines
     * multiple `adb shell` calls into a single command.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be processed.
     * @param {Array<string>} permissions - The list of permissions to be granted.
     * @throws {Error} If there was an error while changing permissions.
     */
    function grantPermissions(this: import("../adb.js").ADB, pkg: string, permissions: Array<string>): Promise<void>;
    /**
     * Grant single permission for the particular package.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be processed.
     * @param {string} permission - The full name of the permission to be granted.
     * @throws {Error} If there was an error while changing permissions.
     */
    function grantPermission(this: import("../adb.js").ADB, pkg: string, permission: string): Promise<void>;
    /**
     * Revoke single permission from the particular package.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be processed.
     * @param {string} permission - The full name of the permission to be revoked.
     * @throws {Error} If there was an error while changing permissions.
     */
    function revokePermission(this: import("../adb.js").ADB, pkg: string, permission: string): Promise<void>;
    /**
     * Retrieve the list of granted permissions for the particular package.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be processed.
     * @param {string?} [cmdOutput=null] - Optional parameter containing command output of
     * _dumpsys package_ command. It may speed up the method execution.
     * @return {Promise<string[]>} The list of granted permissions or an empty list.
     * @throws {Error} If there was an error while changing permissions.
     */
    function getGrantedPermissions(this: import("../adb.js").ADB, pkg: string, cmdOutput?: string | null | undefined): Promise<string[]>;
    /**
     * Retrieve the list of denied permissions for the particular package.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be processed.
     * @param {string?} [cmdOutput=null] - Optional parameter containing command output of
     * _dumpsys package_ command. It may speed up the method execution.
     * @return {Promise<string[]>} The list of denied permissions or an empty list.
     */
    function getDeniedPermissions(this: import("../adb.js").ADB, pkg: string, cmdOutput?: string | null | undefined): Promise<string[]>;
    /**
     * Retrieve the list of requested permissions for the particular package.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be processed.
     * @param {string?} [cmdOutput=null] - Optional parameter containing command output of
     *                                    _dumpsys package_ command. It may speed up the method execution.
     * @return {Promise<string[]>} The list of requested permissions or an empty list.
     */
    function getReqPermissions(this: import("../adb.js").ADB, pkg: string, cmdOutput?: string | null | undefined): Promise<string[]>;
    /**
     * Retrieve the list of location providers for the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<string[]>} The list of available location providers or an empty list.
     */
    function getLocationProviders(this: import("../adb.js").ADB): Promise<string[]>;
    /**
     * Toggle the state of GPS location provider.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} enabled - Whether to enable (true) or disable (false) the GPS provider.
     */
    function toggleGPSLocationProvider(this: import("../adb.js").ADB, enabled: boolean): Promise<void>;
    /**
     * Set hidden api policy to manage access to non-SDK APIs.
     * https://developer.android.com/preview/restrictions-non-sdk-interfaces
     *
     * @this {import('../adb.js').ADB}
     * @param {number|string} value - The API enforcement policy.
     *     For Android P
     *     0: Disable non-SDK API usage detection. This will also disable logging, and also break the strict mode API,
     *        detectNonSdkApiUsage(). Not recommended.
     *     1: "Just warn" - permit access to all non-SDK APIs, but keep warnings in the log.
     *        The strict mode API will keep working.
     *     2: Disallow usage of dark grey and black listed APIs.
     *     3: Disallow usage of blacklisted APIs, but allow usage of dark grey listed APIs.
     *
     *     For Android Q
     *     https://developer.android.com/preview/non-sdk-q#enable-non-sdk-access
     *     0: Disable all detection of non-SDK interfaces. Using this setting disables all log messages for non-SDK interface usage
     *        and prevents you from testing your app using the StrictMode API. This setting is not recommended.
     *     1: Enable access to all non-SDK interfaces, but print log messages with warnings for any non-SDK interface usage.
     *        Using this setting also allows you to test your app using the StrictMode API.
     *     2: Disallow usage of non-SDK interfaces that belong to either the black list
     *        or to a restricted greylist for your target API level.
     *
     * @param {boolean} [ignoreError=false] Whether to ignore an exception in 'adb shell settings put global' command
     * @throws {error} If there was an error and ignoreError was true while executing 'adb shell settings put global'
     *                 command on the device under test.
     */
    function setHiddenApiPolicy(this: import("../adb.js").ADB, value: number | string, ignoreError?: boolean | undefined): Promise<void>;
    /**
     * Reset access to non-SDK APIs to its default setting.
     * https://developer.android.com/preview/restrictions-non-sdk-interfaces
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} [ignoreError=false] Whether to ignore an exception in 'adb shell settings delete global' command
     * @throws {error} If there was an error and ignoreError was true while executing 'adb shell settings delete global'
     *                 command on the device under test.
     */
    function setDefaultHiddenApiPolicy(this: import("../adb.js").ADB, ignoreError?: boolean | undefined): Promise<void>;
    /**
     * Stop the particular package if it is running and clears its application data.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} pkg - The package name to be processed.
     */
    function stopAndClear(this: import("../adb.js").ADB, pkg: string): Promise<void>;
    /**
     * Retrieve the list of available input methods (IMEs) for the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<string[]>} The list of IME names or an empty list.
     */
    function availableIMEs(this: import("../adb.js").ADB): Promise<string[]>;
    /**
     * Retrieve the list of enabled input methods (IMEs) for the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<string[]>} The list of enabled IME names or an empty list.
     */
    function enabledIMEs(this: import("../adb.js").ADB): Promise<string[]>;
    /**
     * Enable the particular input method on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} imeId - One of existing IME ids.
     */
    function enableIME(this: import("../adb.js").ADB, imeId: string): Promise<void>;
    /**
     * Disable the particular input method on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} imeId - One of existing IME ids.
     */
    function disableIME(this: import("../adb.js").ADB, imeId: string): Promise<void>;
    /**
     * Set the particular input method on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} imeId - One of existing IME ids.
     */
    function setIME(this: import("../adb.js").ADB, imeId: string): Promise<void>;
    /**
     * Get the default input method on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<string|null>} The name of the default input method
     */
    function defaultIME(this: import("../adb.js").ADB): Promise<string | null>;
    /**
     * Send the particular keycode to the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} keycode - The actual key code to be sent.
     */
    function keyevent(this: import("../adb.js").ADB, keycode: string | number): Promise<void>;
    /**
     * Send the particular text or a number to the device under test.
     * The text gets properly escaped before being passed to ADB.
     * Noop if the text is empty.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} text - The actual text to be sent.
     * @throws {Error} If it is impossible to escape the given string
     */
    function inputText(this: import("../adb.js").ADB, text: string | number): Promise<void>;
    /**
     * Clear the active text field on the device under test by sending
     * special keyevents to it.
     *
     * @this {import('../adb.js').ADB}
     * @param {number} [length=100] - The maximum length of the text in the field to be cleared.
     */
    function clearTextField(this: import("../adb.js").ADB, length?: number | undefined): Promise<void>;
    /**
     * Send the special keycode to the device under test in order to lock it.
     * @this {import('../adb.js').ADB}
     */
    function lock(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Send the special keycode to the device under test in order to emulate
     * Back button tap.
     * @this {import('../adb.js').ADB}
     */
    function back(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Send the special keycode to the device under test in order to emulate
     * Home button tap.
     * @this {import('../adb.js').ADB}
     */
    function goToHome(this: import("../adb.js").ADB): Promise<void>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {string} the actual path to adb executable.
     */
    function getAdbPath(this: import("../adb.js").ADB): string;
    /**
     * Retrieve current screen orientation of the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<number?>} The current orientation encoded as an integer number.
     */
    function getScreenOrientation(this: import("../adb.js").ADB): Promise<number | null>;
    /**
     * Send an arbitrary Telnet command to the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} command - The command to be sent.
     * @return {Promise<string>} The actual output of the given command.
     */
    function sendTelnetCommand(this: import("../adb.js").ADB, command: string): Promise<string>;
    /**
     * Check the state of Airplane mode on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<boolean>} True if Airplane mode is enabled.
     */
    function isAirplaneModeOn(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Change the state of Airplane mode in Settings on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to enable the Airplane mode in Settings and false to disable it.
     */
    function setAirplaneMode(this: import("../adb.js").ADB, on: boolean): Promise<void>;
    /**
     * Change the state of the bluetooth service on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to enable bluetooth service and false to disable it.
     */
    function setBluetoothOn(this: import("../adb.js").ADB, on: boolean): Promise<void>;
    /**
     * Change the state of the NFC service on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to enable NFC service and false to disable it.
     * @throws {Error} If there was an error while changing the service state
     */
    function setNfcOn(this: import("../adb.js").ADB, on: boolean): Promise<void>;
    /**
     * Broadcast the state of Airplane mode on the device under test.
     * This method should be called after {@link #setAirplaneMode}, otherwise
     * the mode change is not going to be applied for the device.
     * ! This API requires root since Android API 24. Since API 30
     * there is a dedicated adb command to change airplane mode state, which
     * does not require to call this one afterwards.
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to broadcast enable and false to broadcast disable.
     */
    function broadcastAirplaneMode(this: import("../adb.js").ADB, on: boolean): Promise<void>;
    /**
     * Check the state of WiFi on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<boolean>} True if WiFi is enabled.
     */
    function isWifiOn(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Check the state of Data transfer on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<boolean>} True if Data transfer is enabled.
     */
    function isDataOn(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Check the state of animation on the device under test below:
     *   - animator_duration_scale
     *   - transition_animation_scale
     *   - window_animation_scale
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<boolean>} True if at least one of animation scale settings
     *                   is not equal to '0.0'.
     */
    function isAnimationOn(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Set animation scale with the given value via adb shell settings command.
     *   - animator_duration_scale
     *   - transition_animation_scale
     *   - window_animation_scale
     * API level 24 and newer OS versions may change the animation, at least emulators are so.
     * API level 28+ real devices checked this worked, but we haven't checked older ones
     * with real devices.
     *
     * @this {import('../adb.js').ADB}
     * @param {number} value Animation scale value (int or float) to set.
     *                       The minimum value of zero disables animations.
     *                       By increasing the value, animations become slower.
     *                       '1' is the system default animation scale.
     * @return {Promise<void>}
     * @throws {Error} If the adb setting command raises an exception.
     */
    function setAnimationScale(this: import("../adb.js").ADB, value: number): Promise<void>;
    /**
     * Forcefully recursively remove a path on the device under test.
     * Be careful while calling this method.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} path - The path to be removed recursively.
     */
    function rimraf(this: import("../adb.js").ADB, path: string): Promise<void>;
    /**
     * Send a file to the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} localPath - The path to the file on the local file system.
     * @param {string} remotePath - The destination path on the remote device.
     * @param {object} [opts] - Additional options mapping. See
     *                        https://github.com/appium/node-teen_process,
     *                        _exec_ method options, for more information about available
     *                        options.
     */
    function push(this: import("../adb.js").ADB, localPath: string, remotePath: string, opts?: object): Promise<void>;
    /**
     * Receive a file from the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} remotePath - The source path on the remote device.
     * @param {string} localPath - The destination path to the file on the local file system.
     * @param {import('teen_process').TeenProcessExecOptions} [opts={}] - Additional options mapping. See
     * https://github.com/appium/node-teen_process,
     * _exec_ method options, for more information about available
     * options.
     */
    function pull(this: import("../adb.js").ADB, remotePath: string, localPath: string, opts?: import("teen_process").TeenProcessExecOptions | undefined): Promise<void>;
    /**
     * Check whether the process with the particular name is running on the device
     * under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} processName - The name of the process to be checked.
     * @return {Promise<boolean>} True if the given process is running.
     * @throws {Error} If the given process name is not a valid class name.
     */
    function processExists(this: import("../adb.js").ADB, processName: string): Promise<boolean>;
    /**
     * Get TCP port forwarding with adb on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<string[]>} The output of the corresponding adb command.
     * An array contains each forwarding line of output
     */
    function getForwardList(this: import("../adb.js").ADB): Promise<string[]>;
    /**
     * Setup TCP port forwarding with adb on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} systemPort - The number of the local system port.
     * @param {string|number} devicePort - The number of the remote device port.
     */
    function forwardPort(this: import("../adb.js").ADB, systemPort: string | number, devicePort: string | number): Promise<void>;
    /**
     * Remove TCP port forwarding with adb on the device under test. The forwarding
     * for the given port should be setup with {@link #forwardPort} first.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} systemPort - The number of the local system port
     *                                     to remove forwarding on.
     */
    function removePortForward(this: import("../adb.js").ADB, systemPort: string | number): Promise<void>;
    /**
     * Get TCP port forwarding with adb on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<string[]>} The output of the corresponding adb command.
     * An array contains each forwarding line of output
     */
    function getReverseList(this: import("../adb.js").ADB): Promise<string[]>;
    /**
     * Setup TCP port forwarding with adb on the device under test.
     * Only available for API 21+.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} devicePort - The number of the remote device port.
     * @param {string|number} systemPort - The number of the local system port.
     */
    function reversePort(this: import("../adb.js").ADB, devicePort: string | number, systemPort: string | number): Promise<void>;
    /**
     * Remove TCP port forwarding with adb on the device under test. The forwarding
     * for the given port should be setup with {@link #forwardPort} first.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} devicePort - The number of the remote device port
     *                                     to remove forwarding on.
     */
    function removePortReverse(this: import("../adb.js").ADB, devicePort: string | number): Promise<void>;
    /**
     * Setup TCP port forwarding with adb on the device under test. The difference
     * between {@link #forwardPort} is that this method does setup for an abstract
     * local port.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} systemPort - The number of the local system port.
     * @param {string|number} devicePort - The number of the remote device port.
     */
    function forwardAbstractPort(this: import("../adb.js").ADB, systemPort: string | number, devicePort: string | number): Promise<void>;
    /**
     * Execute ping shell command on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<boolean>} True if the command output contains 'ping' substring.
     * @throws {Error} If there was an error while executing 'ping' command on the
     *                 device under test.
     */
    function ping(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Restart the device under test using adb commands.
     *
     * @this {import('../adb.js').ADB}
     * @throws {Error} If start fails.
     */
    function restart(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Start the logcat process to gather logs.
     *
     * @this {import('../adb.js').ADB}
     * @param {import('../logcat.js').LogcatOpts} [opts={}]
     * @throws {Error} If restart fails.
     */
    function startLogcat(this: import("../adb.js").ADB, opts?: import("../logcat").LogcatOpts | undefined): Promise<void>;
    /**
     * Stop the active logcat process which gathers logs.
     * The call will be ignored if no logcat process is running.
     * @this {import('../adb.js').ADB}
     */
    function stopLogcat(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Retrieve the output from the currently running logcat process.
     * The logcat process should be executed by {2link #startLogcat} method.
     *
     * @this {import('../adb.js').ADB}
     * @return {string[]} The collected logcat output.
     * @throws {Error} If logcat process is not running.
     */
    function getLogcatLogs(this: import("../adb.js").ADB): string[];
    /**
     * Listener function, which accepts one argument.
     *
     * The argument is a log record object with `timestamp`, `level` and `message` properties.
     * @callback LogcatListener
     * @param {LogcatRecord} record
     */
    /**
     * @typedef LogcatRecord
     * @property {number} timestamp
     * @property {string} level
     * @property {string} message
     */
    /**
     * Set the callback for the logcat output event.
     *
     * @this {import('../adb.js').ADB}
     * @param {LogcatListener} listener - Listener function
     * @throws {Error} If logcat process is not running.
     */
    function setLogcatListener(this: import("../adb.js").ADB, listener: LogcatListener): void;
    /**
     * Removes the previously set callback for the logcat output event.
     *
     * @this {import('../adb.js').ADB}
     * @param {LogcatListener} listener - The listener function, which has been previously
     *                              passed to `setLogcatListener`
     * @throws {Error} If logcat process is not running.
     */
    function removeLogcatListener(this: import("../adb.js").ADB, listener: LogcatListener): void;
    /**
     * At some point of time Google has changed the default `ps` behaviour, so it only
     * lists processes that belong to the current shell user rather to all
     * users. It is necessary to execute ps with -A command line argument
     * to mimic the previous behaviour.
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<string>} the output of `ps` command where all processes are included
     */
    function listProcessStatus(this: import("../adb.js").ADB): Promise<string>;
    /**
     * Returns process name for the given process identifier
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} pid - The valid process identifier
     * @throws {Error} If the given PID is either invalid or is not present
     * in the active processes list
     * @returns {Promise<string>} The process name
     */
    function getNameByPid(this: import("../adb.js").ADB, pid: string | number): Promise<string>;
    /**
     * Get the list of process ids for the particular process on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} name - The part of process name.
     * @return {Promise<number[]>} The list of matched process IDs or an empty list.
     * @throws {Error} If the passed process name is not a valid one
     */
    function getPIDsByName(this: import("../adb.js").ADB, name: string): Promise<number[]>;
    /**
     * Get the list of process ids for the particular process on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} name - The part of process name.
     */
    function killProcessesByName(this: import("../adb.js").ADB, name: string): Promise<void>;
    /**
     * Kill the particular process on the device under test.
     * The current user is automatically switched to root if necessary in order
     * to properly kill the process.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} pid - The ID of the process to be killed.
     * @throws {Error} If the process cannot be killed.
     */
    function killProcessByPID(this: import("../adb.js").ADB, pid: string | number): Promise<void>;
    /**
     * Broadcast process killing on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} intent - The name of the intent to broadcast to.
     * @param {string} processName - The name of the killed process.
     * @throws {error} If the process was not killed.
     */
    function broadcastProcessEnd(this: import("../adb.js").ADB, intent: string, processName: string): Promise<void>;
    /**
     * Broadcast a message to the given intent.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} intent - The name of the intent to broadcast to.
     * @throws {error} If intent name is not a valid class name.
     */
    function broadcast(this: import("../adb.js").ADB, intent: string): Promise<void>;
    /**
     * Get the particular property of the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} property - The name of the property. This name should
     *                            be known to _adb shell getprop_ tool.
     *
     * @return {Promise<string>} The value of the given property.
     */
    function getDeviceProperty(this: import("../adb.js").ADB, property: string): Promise<string>;
    /**
     * @typedef {Object} SetPropOpts
     * @property {boolean} [privileged=true] - Do we run setProp as a privileged command? Default true.
     */
    /**
     * Set the particular property of the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} prop - The name of the property. This name should
     *                            be known to _adb shell setprop_ tool.
     * @param {string} val - The new property value.
     * @param {SetPropOpts} [opts={}]
     *
     * @throws {error} If _setprop_ utility fails to change property value.
     */
    function setDeviceProperty(this: import("../adb.js").ADB, prop: string, val: string, opts?: SetPropOpts | undefined): Promise<void>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} Current system language on the device under test.
     */
    function getDeviceSysLanguage(this: import("../adb.js").ADB): Promise<string>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} Current country name on the device under test.
     */
    function getDeviceSysCountry(this: import("../adb.js").ADB): Promise<string>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} Current system locale name on the device under test.
     */
    function getDeviceSysLocale(this: import("../adb.js").ADB): Promise<string>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} Current product language name on the device under test.
     */
    function getDeviceProductLanguage(this: import("../adb.js").ADB): Promise<string>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} Current product country name on the device under test.
     */
    function getDeviceProductCountry(this: import("../adb.js").ADB): Promise<string>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} Current product locale name on the device under test.
     */
    function getDeviceProductLocale(this: import("../adb.js").ADB): Promise<string>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} The model name of the device under test.
     */
    function getModel(this: import("../adb.js").ADB): Promise<string>;
    /**
     * @this {import('../adb.js').ADB}
     * @return {Promise<string>} The manufacturer name of the device under test.
     */
    function getManufacturer(this: import("../adb.js").ADB): Promise<string>;
    /**
     * Get the current screen size.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<string?>} Device screen size as string in format 'WxH' or
     * _null_ if it cannot be determined.
     */
    function getScreenSize(this: import("../adb.js").ADB): Promise<string | null>;
    /**
     * Get the current screen density in dpi
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<number?>} Device screen density as a number or _null_ if it
     * cannot be determined
     */
    function getScreenDensity(this: import("../adb.js").ADB): Promise<number | null>;
    /**
     * Setup HTTP proxy in device global settings.
     * Read https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r21/core/java/android/provider/Settings.java for each property
     *
     * @this {import('../adb.js').ADB}
     * @param {string} proxyHost - The host name of the proxy.
     * @param {string|number} proxyPort - The port number to be set.
     */
    function setHttpProxy(this: import("../adb.js").ADB, proxyHost: string, proxyPort: string | number): Promise<void>;
    /**
     * Delete HTTP proxy in device global settings.
     * Rebooting the test device is necessary to apply the change.
     * @this {import('../adb.js').ADB}
     */
    function deleteHttpProxy(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Set device property.
     * [android.provider.Settings]{@link https://developer.android.com/reference/android/provider/Settings.html}
     *
     * @this {import('../adb.js').ADB}
     * @param {string} namespace - one of {system, secure, global}, case-insensitive.
     * @param {string} setting - property name.
     * @param {string|number} value - property value.
     * @return {Promise<string>} command output.
     */
    function setSetting(this: import("../adb.js").ADB, namespace: string, setting: string, value: string | number): Promise<string>;
    /**
     * Get device property.
     * [android.provider.Settings]{@link https://developer.android.com/reference/android/provider/Settings.html}
     *
     * @this {import('../adb.js').ADB}
     * @param {string} namespace - one of {system, secure, global}, case-insensitive.
     * @param {string} setting - property name.
     * @return {Promise<string>} property value.
     */
    function getSetting(this: import("../adb.js").ADB, namespace: string, setting: string): Promise<string>;
    /**
     * Retrieve the `adb bugreport` command output. This
     * operation may take up to several minutes.
     *
     * @this {import('../adb.js').ADB}
     * @param {number} [timeout=120000] - Command timeout in milliseconds
     * @returns {Promise<string>} Command stdout
     */
    function bugreport(this: import("../adb.js").ADB, timeout?: number | undefined): Promise<string>;
    /**
     * @typedef {Object} ScreenrecordOptions
     * @property {string} [videoSize] - The format is widthxheight.
     *                  The default value is the device's native display resolution (if supported),
     *                  1280x720 if not. For best results,
     *                  use a size supported by your device's Advanced Video Coding (AVC) encoder.
     *                  For example, "1280x720"
     * @property {boolean} [bugReport] - Set it to `true` in order to display additional information on the video overlay,
     *                                  such as a timestamp, that is helpful in videos captured to illustrate bugs.
     *                                  This option is only supported since API level 27 (Android P).
     * @property {string|number} [timeLimit] - The maximum recording time, in seconds.
     *                                        The default (and maximum) value is 180 (3 minutes).
     * @property {string|number} [bitRate] - The video bit rate for the video, in megabits per second.
     *                The default value is 4. You can increase the bit rate to improve video quality,
     *                but doing so results in larger movie files.
     */
    /**
     * Initiate screenrecord utility on the device
     *
     * @this {import('../adb.js').ADB}
     * @param {string} destination - Full path to the writable media file destination
     *                               on the device file system.
     * @param {ScreenrecordOptions} [options={}]
     * @returns {SubProcess} screenrecord process, which can be then controlled by the client code
     */
    function screenrecord(this: import("../adb.js").ADB, destination: string, options?: ScreenrecordOptions | undefined): SubProcess;
    /**
     * Executes the given function with the given input method context
     * and then restores the IME to the original value
     *
     * @this {import('../adb.js').ADB}
     * @param {string} ime - Valid IME identifier
     * @param {Function} fn - Function to execute
     * @returns {Promise<any>} The result of the given function
     */
    function runInImeContext(this: import("../adb.js").ADB, ime: string, fn: Function): Promise<any>;
    /**
     * Get tz database time zone formatted timezone
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<string>} TZ database Time Zones format
     * @throws {Error} If any exception is reported by adb shell.
     */
    function getTimeZone(this: import("../adb.js").ADB): Promise<string>;
    /**
     * Retrieves the list of features supported by the device under test
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<string[]>} the list of supported feature names or an empty list.
     * An example adb command output:
     * ```
     * cmd
     * ls_v2
     * fixed_push_mkdir
     * shell_v2
     * abb
     * stat_v2
     * apex
     * abb_exec
     * remount_shell
     * fixed_push_symlink_timestamp
     * ```
     * @throws {Error} if there was an error while retrieving the list
     */
    function listFeatures(this: import("../adb.js").ADB): Promise<string[]>;
    /**
     * Checks the state of streamed install feature.
     * This feature allows to speed up apk installation
     * since it does not require the original apk to be pushed to
     * the device under test first, which also saves space.
     * Although, it is required that both the device under test
     * and the adb server have the mentioned functionality.
     * See https://github.com/aosp-mirror/platform_system_core/blob/master/adb/client/adb_install.cpp
     * for more details
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<boolean>} `true` if the feature is supported by both adb and the
     * device under test
     */
    function isStreamedInstallSupported(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Checks whether incremental install feature is supported by ADB.
     * Read https://developer.android.com/preview/features#incremental
     * for more details on it.
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<boolean>} `true` if the feature is supported by both adb and the
     * device under test
     */
    function isIncrementalInstallSupported(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Retrieves the list of packages from Doze whitelist on Android 8+
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<string[]>} The list of whitelisted packages. An example output:
     * system,com.android.shell,2000
     * system,com.google.android.cellbroadcastreceiver,10143
     * user,io.appium.settings,10157
     */
    function getDeviceIdleWhitelist(this: import("../adb.js").ADB): Promise<string[]>;
    /**
     * Adds an existing package(s) into the Doze whitelist on Android 8+
     *
     * @this {import('../adb.js').ADB}
     * @param  {...string} packages One or more packages to add. If the package
     * already exists in the whitelist then it is only going to be added once.
     * If the package with the given name is not installed/not known then an error
     * will be thrown.
     * @returns {Promise<boolean>} `true` if the command to add package(s) has been executed
     */
    function addToDeviceIdleWhitelist(this: import("../adb.js").ADB, ...packages: string[]): Promise<boolean>;
    /**
     * Takes a screenshot of the given display or the default display.
     *
     * @this {import('../adb.js').ADB}
     * @param {number|string?} displayId A valid display identifier. If
     * no identifier is provided then the screenshot of the default display is returned.
     * Note that only recent Android APIs provide multi-screen support.
     * @returns {Promise<Buffer>} PNG screenshot payload
     */
    function takeScreenshot(this: import("../adb.js").ADB, displayId: number | (string | null)): Promise<Buffer>;
    /**
     * Change the state of WiFi on the device under test.
     * Only works for real devices since API 30
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to enable and false to disable it.
     * @param {boolean} [isEmulator=false] - Set it to true if the device under test
     *                                       is an emulator rather than a real device.
     */
    function setWifiState(this: import("../adb.js").ADB, on: boolean, isEmulator?: boolean | undefined): Promise<void>;
    /**
     * Change the state of Data transfer on the device under test.
     * Only works for real devices since API 30
     *
     * @this {import('../adb.js').ADB}
     * @param {boolean} on - True to enable and false to disable it.
     * @param {boolean} [isEmulator=false] - Set it to true if the device under test
     *                                       is an emulator rather than a real device.
     */
    function setDataState(this: import("../adb.js").ADB, on: boolean, isEmulator?: boolean | undefined): Promise<void>;
}
import { SubProcess } from 'teen_process';
//# sourceMappingURL=adb-commands.d.ts.map