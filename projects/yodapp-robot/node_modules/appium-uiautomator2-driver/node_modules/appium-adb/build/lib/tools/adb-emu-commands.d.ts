export default emuMethods;
export type Sensors = import("type-fest").ValueOf<typeof emuMethods.SENSORS>;
export type NetworkSpeed = import("type-fest").ValueOf<typeof emuMethods.NETWORK_SPEED>;
export type GsmVoiceStates = import("type-fest").ValueOf<typeof emuMethods.GSM_VOICE_STATES>;
export type GsmCallActions = import("type-fest").ValueOf<typeof emuMethods.GSM_CALL_ACTIONS>;
export type PowerAcStates = import("type-fest").ValueOf<typeof emuMethods.POWER_AC_STATES>;
export type EmuInfo = {
    /**
     * Emulator name, for example `Pixel_XL_API_30`
     */
    name: string;
    /**
     * Full path to the emulator config .ini file,
     * for example `/Users/user/.android/avd/Pixel_XL_API_30.ini`
     */
    config: string;
};
export type GsmSignalStrength = 0 | 1 | 2 | 3 | 4;
export type ExecTelnetOptions = {
    /**
     * A timeout used to wait for a server
     * reply to the given command
     */
    execTimeout?: number | undefined;
    /**
     * Console connection timeout in milliseconds
     */
    connTimeout?: number | undefined;
    /**
     * Telnet console initialization timeout
     * in milliseconds (the time between connection happens and the command prompt
     * is available)
     */
    initTimeout?: number | undefined;
    /**
     * The emulator port number. The method will try to parse it
     * from the current device identifier if unset
     */
    port?: string | number | undefined;
};
export type EmuVersionInfo = {
    /**
     * The actual revision number, for example '30.0.5'
     */
    revision?: string | undefined;
    /**
     * The build identifier, for example 6306047
     */
    buildId?: number | undefined;
};
export type ADBEmuCommands = typeof emuMethods;
declare namespace emuMethods {
    let POWER_AC_STATES: Readonly<{
        POWER_AC_ON: "on";
        POWER_AC_OFF: "off";
    }>;
    let GSM_CALL_ACTIONS: Readonly<{
        GSM_CALL: "call";
        GSM_ACCEPT: "accept";
        GSM_CANCEL: "cancel";
        GSM_HOLD: "hold";
    }>;
    let GSM_VOICE_STATES: Readonly<{
        GSM_VOICE_UNREGISTERED: "unregistered";
        GSM_VOICE_HOME: "home";
        GSM_VOICE_ROAMING: "roaming";
        GSM_VOICE_SEARCHING: "searching";
        GSM_VOICE_DENIED: "denied";
        GSM_VOICE_OFF: "off";
        GSM_VOICE_ON: "on";
    }>;
    let GSM_SIGNAL_STRENGTHS: readonly number[];
    let NETWORK_SPEED: Readonly<{
        GSM: "gsm";
        SCSD: "scsd";
        GPRS: "gprs";
        EDGE: "edge";
        UMTS: "umts";
        HSDPA: "hsdpa";
        LTE: "lte";
        EVDO: "evdo";
        FULL: "full";
    }>;
    let SENSORS: Readonly<{
        ACCELERATION: "acceleration";
        GYROSCOPE: "gyroscope";
        MAGNETIC_FIELD: "magnetic-field";
        ORIENTATION: "orientation";
        TEMPERATURE: "temperature";
        PROXIMITY: "proximity";
        LIGHT: "light";
        PRESSURE: "pressure";
        HUMIDITY: "humidity";
        MAGNETIC_FIELD_UNCALIBRATED: "magnetic-field-uncalibrated";
        GYROSCOPE_UNCALIBRATED: "gyroscope-uncalibrated";
        HINGE_ANGLE0: "hinge-angle0";
        HINGE_ANGLE1: "hinge-angle1";
        HINGE_ANGLE2: "hinge-angle2";
        HEART_RATE: "heart-rate";
        RGBC_LIGHT: "rgbc-light";
    }>;
    /**
     * Check the emulator state.
     *
     * @this {import('../adb.js').ADB}
     * @return {Promise<boolean>} True if Emulator is visible to adb.
     */
    function isEmulatorConnected(this: import("../adb.js").ADB): Promise<boolean>;
    /**
     * Verify the emulator is connected.
     *
     * @this {import('../adb.js').ADB}
     * @throws {Error} If Emulator is not visible to adb.
     */
    function verifyEmulatorConnected(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Emulate fingerprint touch event on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} fingerprintId - The ID of the fingerprint.
     */
    function fingerprint(this: import("../adb.js").ADB, fingerprintId: string): Promise<void>;
    /**
     * Change the display orientation on the connected emulator.
     * The orientation is changed (PI/2 is added) every time
     * this method is called.
     * @this {import('../adb.js').ADB}
     */
    function rotate(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Emulate power state change on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {PowerAcStates} [state='on'] - Either 'on' or 'off'.
     */
    function powerAC(this: import("../adb.js").ADB, state?: import("type-fest").ValueOf<Readonly<{
        POWER_AC_ON: "on";
        POWER_AC_OFF: "off";
    }>, "POWER_AC_ON" | "POWER_AC_OFF"> | undefined): Promise<void>;
    /**
     * Emulate sensors values on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} sensor - Sensor type declared in SENSORS items.
     * @param {Sensors} value  - Number to set as the sensor value.
     * @throws {TypeError} - If sensor type or sensor value is not defined
     */
    function sensorSet(this: import("../adb.js").ADB, sensor: string, value: Sensors): Promise<void>;
    /**
     * Emulate power capacity change on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} [percent=100] - Percentage value in range [0, 100].
     */
    function powerCapacity(this: import("../adb.js").ADB, percent?: string | number | undefined): Promise<void>;
    /**
     * Emulate power off event on the connected emulator.
     * @this {import('../adb.js').ADB}
     */
    function powerOFF(this: import("../adb.js").ADB): Promise<void>;
    /**
     * Emulate send SMS event on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} phoneNumber - The phone number of message sender.
     * @param {string} [message=''] - The message content.
     * @throws {TypeError} If phone number has invalid format.
     */
    function sendSMS(this: import("../adb.js").ADB, phoneNumber: string | number, message?: string | undefined): Promise<void>;
    /**
     * Emulate GSM call event on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {string|number} phoneNumber - The phone number of the caller.
     * @param {GsmCallActions} action - One of available GSM call actions.
     * @throws {TypeError} If phone number has invalid format.
     * @throws {TypeError} If _action_ value is invalid.
     */
    function gsmCall(this: import("../adb.js").ADB, phoneNumber: string | number, action: GsmCallActions): Promise<void>;
    /**
     * Emulate GSM signal strength change event on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {GsmSignalStrength} [strength=4] - A number in range [0, 4];
     * @throws {TypeError} If _strength_ value is invalid.
     */
    function gsmSignal(this: import("../adb.js").ADB, strength?: GsmSignalStrength | undefined): Promise<void>;
    /**
     * Emulate GSM voice event on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {GsmVoiceStates} [state='on'] - Either 'on' or 'off'.
     * @throws {TypeError} If _state_ value is invalid.
     */
    function gsmVoice(this: import("../adb.js").ADB, state?: import("type-fest").ValueOf<Readonly<{
        GSM_VOICE_UNREGISTERED: "unregistered";
        GSM_VOICE_HOME: "home";
        GSM_VOICE_ROAMING: "roaming";
        GSM_VOICE_SEARCHING: "searching";
        GSM_VOICE_DENIED: "denied";
        GSM_VOICE_OFF: "off";
        GSM_VOICE_ON: "on";
    }>, "GSM_VOICE_UNREGISTERED" | "GSM_VOICE_HOME" | "GSM_VOICE_ROAMING" | "GSM_VOICE_SEARCHING" | "GSM_VOICE_DENIED" | "GSM_VOICE_OFF" | "GSM_VOICE_ON"> | undefined): Promise<void>;
    /**
     * Emulate network speed change event on the connected emulator.
     *
     * @this {import('../adb.js').ADB}
     * @param {NetworkSpeed} [speed='full']
     *  One of possible NETWORK_SPEED values.
     * @throws {TypeError} If _speed_ value is invalid.
     */
    function networkSpeed(this: import("../adb.js").ADB, speed?: import("type-fest").ValueOf<Readonly<{
        GSM: "gsm";
        SCSD: "scsd";
        GPRS: "gprs";
        EDGE: "edge";
        UMTS: "umts";
        HSDPA: "hsdpa";
        LTE: "lte";
        EVDO: "evdo";
        FULL: "full";
    }>, "FULL" | "GSM" | "SCSD" | "GPRS" | "EDGE" | "UMTS" | "HSDPA" | "LTE" | "EVDO"> | undefined): Promise<void>;
    /**
     * @typedef {Object} ExecTelnetOptions
     * @property {number} [execTimeout=60000] A timeout used to wait for a server
     * reply to the given command
     * @property {number} [connTimeout=5000] Console connection timeout in milliseconds
     * @property {number} [initTimeout=5000] Telnet console initialization timeout
     * in milliseconds (the time between connection happens and the command prompt
     * is available)
     * @property {number|string} [port] The emulator port number. The method will try to parse it
     * from the current device identifier if unset
     */
    /**
     * Executes a command through emulator telnet console interface and returns its output
     *
     * @this {import('../adb.js').ADB}
     * @param {string[]|string} cmd - The actual command to execute. See
     * https://developer.android.com/studio/run/emulator-console for more details
     * on available commands
     * @param {ExecTelnetOptions} [opts={}]
     * @returns {Promise<string>} The command output
     * @throws {Error} If there was an error while connecting to the Telnet console
     * or if the given command returned non-OK response
     */
    function execEmuConsoleCommand(this: import("../adb.js").ADB, cmd: string[] | string, opts?: ExecTelnetOptions | undefined): Promise<string>;
    /**
     * @typedef {Object} EmuVersionInfo
     * @property {string} [revision] The actual revision number, for example '30.0.5'
     * @property {number} [buildId] The build identifier, for example 6306047
     */
    /**
     * Retrieves emulator version from the file system
     *
     * @this {import('../adb.js').ADB}
     * @returns {Promise<EmuVersionInfo>} If no version info could be parsed then an empty
     * object is returned
     */
    function getEmuVersionInfo(this: import("../adb.js").ADB): Promise<EmuVersionInfo>;
    /**
     * Retrieves emulator image properties from the local file system
     *
     * @this {import('../adb.js').ADB}
     * @param {string} avdName Emulator name. Should NOT start with '@' character
     * @throws {Error} if there was a failure while extracting the properties
     * @returns {Promise<import('@appium/types').StringRecord>} The content of emulator image properties file.
     * Usually this configuration .ini file has the following content:
     *   avd.ini.encoding=UTF-8
     *   path=/Users/username/.android/avd/Pixel_XL_API_30.avd
     *   path.rel=avd/Pixel_XL_API_30.avd
     *   target=android-30
     */
    function getEmuImageProperties(this: import("../adb.js").ADB, avdName: string): Promise<import("@appium/types").StringRecord>;
    /**
     * Check if given emulator exists in the list of available avds.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} avdName - The name of emulator to verify for existence.
     * Should NOT start with '@' character
     * @throws {Error} If the emulator with given name does not exist.
     */
    function checkAvdExist(this: import("../adb.js").ADB, avdName: string): Promise<boolean>;
}
//# sourceMappingURL=adb-emu-commands.d.ts.map