"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const teen_process_1 = require("teen_process");
const logger_js_1 = __importDefault(require("../logger.js"));
const helpers_js_1 = require("../helpers.js");
const support_1 = require("@appium/support");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const adbkit_apkreader_1 = __importDefault(require("@devicefarmer/adbkit-apkreader"));
const manifestMethods = {};
/**
 * @typedef {Object} APKInfo
 * @property {string} apkPackage - The name of application package, for example 'com.acme.app'.
 * @property {string} [apkActivity] - The name of main application activity.
 */
/**
 * Extract package and main activity name from application manifest.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appPath - The full path to application .apk(s) package
 * @return {Promise<APKInfo>} The parsed application info.
 * @throws {error} If there was an error while getting the data from the given
 *                 application package.
 */
manifestMethods.packageAndLaunchActivityFromManifest = async function packageAndLaunchActivityFromManifest(appPath) {
    if (appPath.endsWith(helpers_js_1.APKS_EXTENSION)) {
        appPath = await this.extractBaseApk(appPath);
    }
    let manifest;
    try {
        const apkReader = await adbkit_apkreader_1.default.open(appPath);
        manifest = await apkReader.readManifest();
    }
    catch (e) {
        logger_js_1.default.debug(e);
        throw new Error(`Cannot extract a manifest from '${appPath}'. ` +
            `Is it a valid Android application?`);
    }
    const { pkg, activity } = (0, helpers_js_1.parseManifest)(manifest);
    logger_js_1.default.info(`Package name: '${pkg}'`);
    logger_js_1.default.info(`Main activity name: '${activity}'`);
    return {
        apkPackage: pkg,
        apkActivity: activity,
    };
};
/**
 * Extract target SDK version from application manifest.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appPath - The full path to .apk(s) package.
 * @return {Promise<number>} The version of the target SDK.
 * @throws {error} If there was an error while getting the data from the given
 *                 application package.
 */
manifestMethods.targetSdkVersionFromManifest = async function targetSdkVersionFromManifest(appPath) {
    logger_js_1.default.debug(`Extracting target SDK version of '${appPath}'`);
    const originalAppPath = appPath;
    if (appPath.endsWith(helpers_js_1.APKS_EXTENSION)) {
        appPath = await this.extractBaseApk(appPath);
    }
    const getTargetSdkViaApkReader = async () => {
        const apkReader = await adbkit_apkreader_1.default.open(appPath);
        const manifest = await apkReader.readManifest();
        if (manifest.usesSdk && lodash_1.default.isInteger(manifest.usesSdk.targetSdkVersion)) {
            return manifest.usesSdk.targetSdkVersion;
        }
        throw new Error('Cannot find the information about targetSdkVersion in the manifest');
    };
    const getTargetSdkViaAapt = async () => {
        await this.initAapt();
        const args = ['dump', 'badging', appPath];
        const { stdout } = await (0, teen_process_1.exec)(( /** @type {import('@appium/types').StringRecord}*/(this.binaries)).aapt, args);
        const targetSdkVersion = /targetSdkVersion:'([^']+)'/g.exec(stdout);
        if (!targetSdkVersion) {
            logger_js_1.default.debug(stdout);
            throw new Error('Cannot parse the command output');
        }
        return parseInt(targetSdkVersion[1], 10);
    };
    /** @type {[string, () => Promise<number>][]} */
    const versionGetters = [
        ['ApkReader', getTargetSdkViaApkReader],
        ['aapt', getTargetSdkViaAapt],
    ];
    for (const [toolName, versionGetter] of versionGetters) {
        try {
            return await versionGetter();
        }
        catch (e) {
            logger_js_1.default.info(`Cannot extract targetSdkVersion of '${originalAppPath}' using ${toolName}. ` +
                `Original error: ${e.message}`);
        }
    }
    throw new Error(`Cannot extract the target SDK version number of '${originalAppPath}' using either of ` +
        `${JSON.stringify(versionGetters.map((pair) => pair[0]))} tools. ` +
        `Check the server log for more details`);
};
/**
 * Extract target SDK version from package information.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The class name of the package installed on the device under test.
 * @param {string?} [cmdOutput=null] - Optional parameter containing the output of
 * _dumpsys package_ command. It may speed up the method execution.
 * @return {Promise<number>} The version of the target SDK.
 */
manifestMethods.targetSdkVersionUsingPKG = async function targetSdkVersionUsingPKG(pkg, cmdOutput = null) {
    const stdout = cmdOutput || await this.shell(['dumpsys', 'package', pkg]);
    const targetSdkVersionMatch = new RegExp(/targetSdk=([^\s\s]+)/g).exec(stdout);
    return targetSdkVersionMatch && targetSdkVersionMatch.length >= 2
        ? parseInt(targetSdkVersionMatch[1], 10)
        : 0;
};
/**
 * Create binary representation of package manifest (usually AndroidManifest.xml).
 * `${manifest}.apk` file will be created as the result of this method
 * containing the compiled manifest.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} manifest - Full path to the initial manifest template
 * @param {string} manifestPackage - The name of the manifest package
 * @param {string} targetPackage - The name of the destination package
 */
manifestMethods.compileManifest = async function compileManifest(manifest, manifestPackage, targetPackage) {
    const { platform, platformPath } = await (0, helpers_js_1.getAndroidPlatformAndPath)(/** @type {string} */ (this.sdkRoot));
    if (!platform || !platformPath) {
        throw new Error('Cannot compile the manifest. The required platform does not exist (API level >= 17)');
    }
    const resultPath = `${manifest}.apk`;
    const androidJarPath = path_1.default.resolve(platformPath, 'android.jar');
    if (await support_1.fs.exists(resultPath)) {
        await support_1.fs.rimraf(resultPath);
    }
    try {
        await this.initAapt2();
        // https://developer.android.com/studio/command-line/aapt2
        const args = [
            'link',
            '-o', resultPath,
            '--manifest', manifest,
            '--rename-manifest-package', manifestPackage,
            '--rename-instrumentation-target-package', targetPackage,
            '-I', androidJarPath,
            '-v',
        ];
        logger_js_1.default.debug(`Compiling the manifest using '${support_1.util.quote([
            ( /** @type {import('@appium/types').StringRecord} */(this.binaries)).aapt2,
            ...args
        ])}'`);
        await (0, teen_process_1.exec)(( /** @type {import('@appium/types').StringRecord} */(this.binaries)).aapt2, args);
    }
    catch (e) {
        logger_js_1.default.debug('Cannot compile the manifest using aapt2. Defaulting to aapt. ' +
            `Original error: ${e.stderr || e.message}`);
        await this.initAapt();
        const args = [
            'package',
            '-M', manifest,
            '--rename-manifest-package', manifestPackage,
            '--rename-instrumentation-target-package', targetPackage,
            '-I', androidJarPath,
            '-F', resultPath,
            '-f',
        ];
        logger_js_1.default.debug(`Compiling the manifest using '${support_1.util.quote([
            ( /** @type {import('@appium/types').StringRecord} */(this.binaries)).aapt,
            ...args
        ])}'`);
        try {
            await (0, teen_process_1.exec)(( /** @type {import('@appium/types').StringRecord} */(this.binaries)).aapt, args);
        }
        catch (e1) {
            throw new Error(`Cannot compile the manifest. Original error: ${e1.stderr || e1.message}`);
        }
    }
    logger_js_1.default.debug(`Compiled the manifest at '${resultPath}'`);
};
/**
 * Replace/insert the specially precompiled manifest file into the
 * particular package.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} manifest - Full path to the precompiled manifest
 *                            created by `compileManifest` method call
 *                            without .apk extension
 * @param {string} srcApk - Full path to the existing valid application package, where
 *                          this manifest has to be insetred to. This package
 *                          will NOT be modified.
 * @param {string} dstApk - Full path to the resulting package.
 *                          The file will be overridden if it already exists.
 */
manifestMethods.insertManifest = async function insertManifest(manifest, srcApk, dstApk) {
    logger_js_1.default.debug(`Inserting manifest '${manifest}', src: '${srcApk}', dst: '${dstApk}'`);
    await support_1.zip.assertValidZip(srcApk);
    await (0, helpers_js_1.unzipFile)(`${manifest}.apk`);
    const manifestName = path_1.default.basename(manifest);
    try {
        await this.initAapt();
        await support_1.fs.copyFile(srcApk, dstApk);
        logger_js_1.default.debug('Moving manifest');
        try {
            await (0, teen_process_1.exec)(( /** @type {import('@appium/types').StringRecord} */(this.binaries)).aapt, [
                'remove', dstApk, manifestName
            ]);
        }
        catch (ign) { }
        await (0, teen_process_1.exec)(( /** @type {import('@appium/types').StringRecord} */(this.binaries)).aapt, [
            'add', dstApk, manifestName
        ], { cwd: path_1.default.dirname(manifest) });
    }
    catch (e) {
        logger_js_1.default.debug('Cannot insert manifest using aapt. Defaulting to zip. ' +
            `Original error: ${e.stderr || e.message}`);
        const tmpRoot = await support_1.tempDir.openDir();
        try {
            // Unfortunately NodeJS does not provide any reliable methods
            // to replace files inside zip archives without loading the
            // whole archive content into RAM
            logger_js_1.default.debug(`Extracting the source apk at '${srcApk}'`);
            await support_1.zip.extractAllTo(srcApk, tmpRoot);
            logger_js_1.default.debug('Moving manifest');
            await support_1.fs.mv(manifest, path_1.default.resolve(tmpRoot, manifestName));
            logger_js_1.default.debug(`Collecting the destination apk at '${dstApk}'`);
            await support_1.zip.toArchive(dstApk, {
                cwd: tmpRoot,
            });
        }
        finally {
            await support_1.fs.rimraf(tmpRoot);
        }
    }
    logger_js_1.default.debug(`Manifest insertion into '${dstApk}' is completed`);
};
/**
 * Check whether package manifest contains Internet permissions.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appPath - The full path to .apk(s) package.
 * @return {Promise<boolean>} True if the manifest requires Internet access permission.
 */
manifestMethods.hasInternetPermissionFromManifest = async function hasInternetPermissionFromManifest(appPath) {
    logger_js_1.default.debug(`Checking if '${appPath}' requires internet access permission in the manifest`);
    if (appPath.endsWith(helpers_js_1.APKS_EXTENSION)) {
        appPath = await this.extractBaseApk(appPath);
    }
    const apkReader = await adbkit_apkreader_1.default.open(appPath);
    const manifest = await apkReader.readManifest();
    return (manifest.usesPermissions || []).some(({ name }) => name === 'android.permission.INTERNET');
};
exports.default = manifestMethods;
/**
 * @typedef {typeof manifestMethods} ManifestMethods
 */
//# sourceMappingURL=android-manifest.js.map