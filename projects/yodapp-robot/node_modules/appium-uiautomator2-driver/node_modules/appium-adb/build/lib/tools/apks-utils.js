"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const teen_process_1 = require("teen_process");
const logger_js_1 = __importDefault(require("../logger.js"));
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const support_1 = require("@appium/support");
const lru_cache_1 = require("lru-cache");
const helpers_js_1 = require("../helpers.js");
const async_lock_1 = __importDefault(require("async-lock"));
const bluebird_1 = __importDefault(require("bluebird"));
const BASE_APK = 'base-master.apk';
const LANGUAGE_APK = (lang) => `base-${lang}.apk`;
/** @type {LRUCache<string, string>} */
const APKS_CACHE = new lru_cache_1.LRUCache({
    max: 10,
    dispose: (extractedFilesRoot) => support_1.fs.rimraf(/** @type {string} */ (extractedFilesRoot)),
});
const APKS_CACHE_GUARD = new async_lock_1.default();
const BUNDLETOOL_TIMEOUT_MS = 4 * 60 * 1000;
const apksUtilsMethods = {};
process.on('exit', () => {
    if (!APKS_CACHE.size) {
        return;
    }
    const paths = /** @type {string[]} */ ([...APKS_CACHE.values()]);
    logger_js_1.default.debug(`Performing cleanup of ${paths.length} cached .apks ` +
        support_1.util.pluralize('package', paths.length));
    for (const appPath of paths) {
        try {
            // Asynchronous calls are not supported in onExit handler
            support_1.fs.rimrafSync(appPath);
        }
        catch (e) {
            logger_js_1.default.warn(e.message);
        }
    }
});
/**
 * Extracts the particular apks package into a temporary folder,
 * finds and returns the full path to the file contained in this apk.
 * The resulting temporary path, where the .apks file has been extracted,
 * will be stored into the internal LRU cache for better performance.
 *
 * @param {string} apks - The full path to the .apks file
 * @param {string|string[]} dstPath - The relative path to the destination file,
 * which is going to be extracted, where each path component is an array item
 * @returns {Promise<string>} Full path to the extracted file
 * @throws {Error} If the requested item does not exist in the extracted archive or the provides
 * apks file is not a valid bundle
 */
async function extractFromApks(apks, dstPath) {
    if (!lodash_1.default.isArray(dstPath)) {
        dstPath = [dstPath];
    }
    return await APKS_CACHE_GUARD.acquire(apks, async () => {
        // It might be that the original file has been replaced,
        // so we need to keep the hash sums instead of the actual file paths
        // as caching keys
        const apksHash = await support_1.fs.hash(apks);
        logger_js_1.default.debug(`Calculated '${apks}' hash: ${apksHash}`);
        if (APKS_CACHE.has(apksHash)) {
            const resultPath = path_1.default.resolve(/** @type {string} */ (APKS_CACHE.get(apksHash)), ...dstPath);
            if (await support_1.fs.exists(resultPath)) {
                return resultPath;
            }
            APKS_CACHE.delete(apksHash);
        }
        const tmpRoot = await support_1.tempDir.openDir();
        logger_js_1.default.debug(`Unpacking application bundle at '${apks}' to '${tmpRoot}'`);
        await (0, helpers_js_1.unzipFile)(apks, tmpRoot);
        const resultPath = path_1.default.resolve(tmpRoot, ...(lodash_1.default.isArray(dstPath) ? dstPath : [dstPath]));
        if (!await support_1.fs.exists(resultPath)) {
            throw new Error(`${lodash_1.default.isArray(dstPath) ? dstPath.join(path_1.default.sep) : dstPath} cannot be found in '${apks}' bundle. ` +
                `Does the archive contain a valid application bundle?`);
        }
        APKS_CACHE.set(apksHash, tmpRoot);
        return resultPath;
    });
}
/**
 * Executes bundletool utility with given arguments and returns the actual stdout
 *
 * @this {import('../adb.js').ADB}
 * @param {Array<String>} args - the list of bundletool arguments
 * @param {string} errorMsg - The customized error message string
 * @returns {Promise<string>} the actual command stdout
 * @throws {Error} If bundletool jar does not exist in PATH or there was an error while
 * executing it
 */
apksUtilsMethods.execBundletool = async function execBundletool(args, errorMsg) {
    await this.initBundletool();
    args = [
        '-jar', ( /** @type {import('@appium/types').StringRecord} */(this.binaries)).bundletool,
        ...args
    ];
    const env = process.env;
    if (this.adbPort) {
        env.ANDROID_ADB_SERVER_PORT = `${this.adbPort}`;
    }
    if (this.adbHost) {
        env.ANDROID_ADB_SERVER_HOST = this.adbHost;
    }
    logger_js_1.default.debug(`Executing bundletool with arguments: ${JSON.stringify(args)}`);
    let stdout;
    try {
        ({ stdout } = await (0, teen_process_1.exec)(await (0, helpers_js_1.getJavaForOs)(), args, {
            env,
            timeout: BUNDLETOOL_TIMEOUT_MS,
        }));
        logger_js_1.default.debug(`Command stdout: ${lodash_1.default.truncate(stdout, { length: 300 })}`);
        return stdout;
    }
    catch (e) {
        if (e.stdout) {
            logger_js_1.default.debug(`Command stdout: ${e.stdout}`);
        }
        if (e.stderr) {
            logger_js_1.default.debug(`Command stderr: ${e.stderr}`);
        }
        throw new Error(`${errorMsg}. Original error: ${e.message}`);
    }
};
/**
 *
 * @this {import('../adb.js').ADB}
 * @param {string} specLocation - The full path to the generated device spec location
 * @returns {Promise<string>} The same `specLocation` value
 * @throws {Error} If it is not possible to retrieve the spec for the current device
 */
apksUtilsMethods.getDeviceSpec = async function getDeviceSpec(specLocation) {
    /** @type {string[]} */
    const args = [
        'get-device-spec',
        '--adb', this.executable.path,
        '--device-id', /** @type {string} */ (this.curDeviceId),
        '--output', specLocation,
    ];
    logger_js_1.default.debug(`Getting the spec for the device '${this.curDeviceId}'`);
    await this.execBundletool(args, 'Cannot retrieve the device spec');
    return specLocation;
};
/**
 * @typedef {Object} InstallMultipleApksOptions
 * @property {?number|string} [timeout=20000] - The number of milliseconds to wait until
 * the installation is completed
 * @property {string} [timeoutCapName=androidInstallTimeout] - The timeout option name
 * users can increase the timeout.
 * @property {boolean} [allowTestPackages=false] - Set to true in order to allow test
 * packages installation.
 * @property {boolean} [useSdcard=false] - Set to true to install the app on sdcard
 * instead of the device memory.
 * @property {boolean} [grantPermissions=false] - Set to true in order to grant all the
 * permissions requested in the application's manifest automatically after the installation
 * is completed under Android 6+.
 * @property {boolean} [partialInstall=false] - Install apks partially. It is used for 'install-multiple'.
 * https://android.stackexchange.com/questions/111064/what-is-a-partial-application-install-via-adb
 */
/**
 * Installs the given apks into the device under test
 *
 * @this {import('../adb.js').ADB}
 * @param {Array<string>} apkPathsToInstall - The full paths to install apks
 * @param {InstallMultipleApksOptions} [options={}] - Installation options
 */
apksUtilsMethods.installMultipleApks = async function installMultipleApks(apkPathsToInstall, options = {}) {
    const installArgs = (0, helpers_js_1.buildInstallArgs)(await this.getApiLevel(), options);
    return await this.adbExec(['install-multiple', ...installArgs, ...apkPathsToInstall], {
        // @ts-ignore This validation works
        timeout: isNaN(options.timeout) ? undefined : options.timeout,
        timeoutCapName: options.timeoutCapName,
    });
};
/**
 * @typedef {Object} InstallApksOptions
 * @property {number|string} [timeout=120000] - The number of milliseconds to wait until
 * the installation is completed
 * @property {string} [timeoutCapName=androidInstallTimeout] - The timeout option name
 * users can increase the timeout.
 * @property {boolean} [allowTestPackages=false] - Set to true in order to allow test
 * packages installation.
 * @property {boolean} [grantPermissions=false] - Set to true in order to grant all the
 * permissions requested in the application's manifest automatically after the installation
 * is completed under Android 6+.
 */
/**
 * Installs the given .apks package into the device under test
 *
 * @this {import('../adb.js').ADB}
 * @param {string} apks - The full path to the .apks file
 * @param {InstallApksOptions} [options={}] - Installation options
 * @throws {Error} If the .apks bundle cannot be installed
 */
apksUtilsMethods.installApks = async function installApks(apks, options = {}) {
    const { grantPermissions, allowTestPackages, timeout, } = options;
    /** @type {string[]} */
    const args = [
        'install-apks',
        '--adb', this.executable.path,
        '--apks', apks,
        '--timeout-millis', `${timeout || helpers_js_1.APKS_INSTALL_TIMEOUT}`,
        '--device-id', /** @type {string} */ (this.curDeviceId),
    ];
    if (allowTestPackages) {
        args.push('--allow-test-only');
    }
    /** @type {Promise[]} */
    const tasks = [
        this.execBundletool(args, `Cannot install '${path_1.default.basename(apks)}' to the device ${this.curDeviceId}`)
    ];
    if (grantPermissions) {
        tasks.push(this.getApkInfo(apks));
    }
    const [, apkInfo] = await bluebird_1.default.all(tasks);
    if (grantPermissions && apkInfo) {
        // TODO: Simplify it after https://github.com/google/bundletool/issues/246 is implemented
        await this.grantAllPermissions(apkInfo.name);
    }
};
/**
 * Extracts and returns the full path to the master .apk file inside the bundle.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} apks - The full path to the .apks file
 * @returns {Promise<string>} The full path to the master bundle .apk
 * @throws {Error} If there was an error while extracting/finding the file
 */
apksUtilsMethods.extractBaseApk = async function extractBaseApk(apks) {
    return await extractFromApks(apks, ['splits', BASE_APK]);
};
/**
 * Extracts and returns the full path to the .apk, which contains the corresponding
 * resources for the given language in the .apks bundle.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} apks - The full path to the .apks file
 * @param {?string} [language=null] - The language abbreviation. The default language is
 * going to be selected if it is not set.
 * @returns {Promise<string>} The full path to the corresponding language .apk or the master .apk
 * if language split is not enabled for the bundle.
 * @throws {Error} If there was an error while extracting/finding the file
 */
apksUtilsMethods.extractLanguageApk = async function extractLanguageApk(apks, language = null) {
    if (language) {
        try {
            return await extractFromApks(apks, ['splits', LANGUAGE_APK(language)]);
        }
        catch (e) {
            logger_js_1.default.debug(e.message);
            logger_js_1.default.info(`Assuming that splitting by language is not enabled for the '${apks}' bundle ` +
                `and returning the main apk instead`);
            return await this.extractBaseApk(apks);
        }
    }
    const defaultLanguages = ['en', 'en_us'];
    for (const lang of defaultLanguages) {
        try {
            return await extractFromApks(apks, ['splits', LANGUAGE_APK(lang)]);
        }
        catch (ign) { }
    }
    logger_js_1.default.info(`Cannot find any split apk for the default languages ${JSON.stringify(defaultLanguages)}. ` +
        `Returning the main apk instead.`);
    return await this.extractBaseApk(apks);
};
/**
 *
 * @param {string} output
 * @returns {boolean}
 */
apksUtilsMethods.isTestPackageOnlyError = function isTestPackageOnlyError(output) {
    return /\[INSTALL_FAILED_TEST_ONLY\]/.test(output);
};
exports.default = apksUtilsMethods;
/**
 * @typedef {typeof apksUtilsMethods} ApksUtils
 */
//# sourceMappingURL=apks-utils.js.map