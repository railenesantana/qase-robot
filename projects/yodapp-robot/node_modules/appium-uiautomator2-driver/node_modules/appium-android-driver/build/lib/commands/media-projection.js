"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mobileStartMediaProjectionRecording = mobileStartMediaProjectionRecording;
exports.mobileIsMediaProjectionRecordingRunning = mobileIsMediaProjectionRecordingRunning;
exports.mobileStopMediaProjectionRecording = mobileStopMediaProjectionRecording;
const support_1 = require("@appium/support");
const lodash_1 = __importDefault(require("lodash"));
const moment_1 = __importDefault(require("moment"));
const node_path_1 = __importDefault(require("node:path"));
// https://github.com/appium/io.appium.settings#internal-audio--video-recording
const DEFAULT_EXT = '.mp4';
const MIN_API_LEVEL = 29;
const DEFAULT_FILENAME_FORMAT = 'YYYY-MM-DDTHH-mm-ss';
/**
 * @this {import('../driver').AndroidDriver}
 * @param {import('./types').StartMediaProjectionRecordingOpts} [options={}]
 * @returns {Promise<boolean>}
 */
async function mobileStartMediaProjectionRecording(options = {}) {
    await verifyMediaProjectionRecordingIsSupported(this.adb);
    const { resolution, priority, maxDurationSec, filename } = options;
    const recorder = this.settingsApp.makeMediaProjectionRecorder();
    const fname = adjustMediaExtension(filename || (0, moment_1.default)().format(DEFAULT_FILENAME_FORMAT));
    const didStart = await recorder.start({
        resolution,
        priority,
        maxDurationSec,
        filename: fname,
    });
    if (didStart) {
        this.log.info(`A new media projection recording '${fname}' has been successfully started`);
    }
    else {
        this.log.info('Another media projection recording is already in progress. There is nothing to start');
    }
    return didStart;
}
/**
 * @this {import('../driver').AndroidDriver}
 * @returns {Promise<boolean>}
 */
async function mobileIsMediaProjectionRecordingRunning() {
    await verifyMediaProjectionRecordingIsSupported(this.adb);
    const recorder = this.settingsApp.makeMediaProjectionRecorder();
    return await recorder.isRunning();
}
/**
 * @this {import('../driver').AndroidDriver}
 * @param {import('./types').StopMediaProjectionRecordingOpts} [options={}]
 * @returns {Promise<string>}
 */
async function mobileStopMediaProjectionRecording(options = {}) {
    await verifyMediaProjectionRecordingIsSupported(this.adb);
    const recorder = this.settingsApp.makeMediaProjectionRecorder();
    if (await recorder.stop()) {
        this.log.info('Successfully stopped a media projection recording. Pulling the recorded media');
    }
    else {
        this.log.info('Media projection recording is not running. There is nothing to stop');
    }
    const recentRecordingPath = await recorder.pullRecent();
    if (!recentRecordingPath) {
        throw new Error(`No recent media projection recording have been found. Did you start any?`);
    }
    const { remotePath } = options;
    if (lodash_1.default.isEmpty(remotePath)) {
        const { size } = await support_1.fs.stat(recentRecordingPath);
        this.log.debug(`The size of the resulting media projection recording is ${support_1.util.toReadableSizeString(size)}`);
    }
    try {
        return await uploadRecordedMedia(recentRecordingPath, remotePath, options);
    }
    finally {
        await support_1.fs.rimraf(node_path_1.default.dirname(recentRecordingPath));
    }
}
// #region Internal helpers
/**
 *
 * @param {string} localFile
 * @param {string} [remotePath]
 * @param {import('./types').StopMediaProjectionRecordingOpts} uploadOptions
 * @returns
 */
async function uploadRecordedMedia(localFile, remotePath, uploadOptions = {}) {
    if (lodash_1.default.isEmpty(remotePath)) {
        return (await support_1.util.toInMemoryBase64(localFile)).toString();
    }
    const { user, pass, method, headers, fileFieldName, formFields, uploadTimeout: timeout, } = uploadOptions;
    /**
     * @type {Omit<import('./types').StopMediaProjectionRecordingOpts, 'uploadTimeout'> & {auth?: {user: string, pass: string}, timeout?: number}}
     */
    const options = {
        method: method || 'PUT',
        headers,
        fileFieldName,
        formFields,
        timeout,
    };
    if (user && pass) {
        options.auth = { user, pass };
    }
    await support_1.net.uploadFile(localFile, /** @type {string} */ (remotePath), options);
    return '';
}
/**
 *
 * @param {string} name
 * @returns {string}
 */
function adjustMediaExtension(name) {
    return lodash_1.default.toLower(name).endsWith(DEFAULT_EXT) ? name : `${name}${DEFAULT_EXT}`;
}
/**
 *
 * @param {ADB} adb
 */
async function verifyMediaProjectionRecordingIsSupported(adb) {
    const apiLevel = await adb.getApiLevel();
    if (apiLevel < MIN_API_LEVEL) {
        throw new Error(`Media projection-based recording is not available on API Level ${apiLevel}. ` +
            `Minimum required API Level is ${MIN_API_LEVEL}.`);
    }
}
// #endregion
/**
 * @typedef {import('appium-adb').ADB} ADB
 */
//# sourceMappingURL=media-projection.js.map