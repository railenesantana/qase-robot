"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionalFfmpegCheck = exports.OptionalFfmpegCheck = exports.optionalGstreamerCheck = exports.OptionalGstreamerCheck = exports.optionalBundletoolCheck = exports.OptionalBundletoolCheck = exports.androidSdkCheck = exports.AndroidSdkCheck = exports.javaHomeValueCheck = exports.JavaHomeValueCheck = exports.javaHomeCheck = exports.androidHomeCheck = void 0;
const utils_1 = require("./utils");
const support_1 = require("@appium/support");
const path_1 = __importDefault(require("path"));
require("@colors/colors");
const appium_adb_1 = require("appium-adb");
const JAVA_HOME_VAR_NAME = support_1.system.isWindows() ? '%JAVA_HOME%' : '$JAVA_HOME';
const ENVIRONMENT_VARS_TUTORIAL_URL = 'https://github.com/appium/java-client/blob/master/docs/environment.md';
const JAVA_HOME_TUTORIAL = 'https://docs.oracle.com/cd/E21454_01/html/821-2531/inst_jdk_javahome_t.html';
const ANDROID_SDK_LINK1 = 'https://developer.android.com/studio#cmdline-tools';
const ANDROID_SDK_LINK2 = 'https://developer.android.com/studio/intro/update#sdk-manager';
const BUNDLETOOL_RELEASES_LINK = 'https://github.com/google/bundletool/releases/';
const GSTREAMER_INSTALL_LINK = 'https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c';
const FFMPEG_INSTALL_LINK = 'https://www.ffmpeg.org/download.html';
/**
 * @typedef EnvVarCheckOptions
 * @property {boolean} [expectDir] If set to true then
 * the path is expected to be a valid folder
 * @property {boolean} [expectFile] If set to true then
 * the path is expected to be a valid file
 */
/** @satisfies {import('@appium/types').IDoctorCheck} */
class EnvVarAndPathCheck {
    /**
     * @param {string} varName
     * @param {EnvVarCheckOptions} [opts={}]
     */
    constructor(varName, opts = {}) {
        this.varName = varName;
        this.opts = opts;
    }
    async diagnose() {
        const varValue = process.env[this.varName];
        if (!varValue) {
            return support_1.doctor.nok(`${this.varName} environment variable is NOT set!`);
        }
        if (!(await support_1.fs.exists(varValue))) {
            let errMsg = `${this.varName} is set to '${varValue}' but this path does not exist!`;
            if (support_1.system.isWindows() && varValue.includes('%')) {
                errMsg += ` Consider replacing all references to other environment variables with absolute paths.`;
            }
            return support_1.doctor.nok(errMsg);
        }
        const stat = await support_1.fs.stat(varValue);
        if (this.opts.expectDir && !stat.isDirectory()) {
            return support_1.doctor.nok(`${this.varName} is expected to be a valid folder, got a file path instead`);
        }
        if (this.opts.expectFile && stat.isDirectory()) {
            return support_1.doctor.nok(`${this.varName} is expected to be a valid file, got a folder path instead`);
        }
        return support_1.doctor.ok(`${this.varName} is set to: ${varValue}`);
    }
    async fix() {
        return (`Make sure the environment variable ${this.varName.bold} is properly configured for the Appium process. ` +
            `Refer ${ENVIRONMENT_VARS_TUTORIAL_URL} for more details.`);
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return false;
    }
}
exports.androidHomeCheck = new EnvVarAndPathCheck('ANDROID_HOME', { expectDir: true });
exports.javaHomeCheck = new EnvVarAndPathCheck('JAVA_HOME', { expectDir: true });
/** @satisfies {import('@appium/types').IDoctorCheck} */
class JavaHomeValueCheck {
    async diagnose() {
        const envVar = process.env.JAVA_HOME;
        if (!envVar) {
            return support_1.doctor.nok(`${JAVA_HOME_VAR_NAME} environment variable must be set`);
        }
        const javaBinaryRelativePath = path_1.default.join('bin', `java${support_1.system.isWindows() ? '.exe' : ''}`);
        const javaBinary = path_1.default.join(envVar, javaBinaryRelativePath);
        if (!(await support_1.fs.exists(javaBinary))) {
            return support_1.doctor.nok(`${JAVA_HOME_VAR_NAME} is set to an invalid value. ` +
                `It must be pointing to a folder containing ${javaBinaryRelativePath}`);
        }
        return support_1.doctor.ok(`'${javaBinaryRelativePath}' exists under '${envVar}'`);
    }
    async fix() {
        return (`Set ${JAVA_HOME_VAR_NAME} environment variable to the root folder path of your local JDK installation. ` +
            `Read ${JAVA_HOME_TUTORIAL}`);
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return false;
    }
}
exports.JavaHomeValueCheck = JavaHomeValueCheck;
exports.javaHomeValueCheck = new JavaHomeValueCheck();
/** @satisfies {import('@appium/types').IDoctorCheck} */
class AndroidSdkCheck {
    constructor() {
        this.TOOL_NAMES = ['adb', 'emulator', `apkanalyzer${support_1.system.isWindows() ? '.bat' : ''}`];
    }
    async diagnose() {
        const listOfTools = this.TOOL_NAMES.join(', ');
        const sdkRoot = (0, appium_adb_1.getSdkRootFromEnv)();
        if (!sdkRoot) {
            return support_1.doctor.nok(`${listOfTools} could not be found because ANDROID_HOME is NOT set!`);
        }
        this.log.info(`   Checking ${listOfTools}`);
        const missingBinaries = [];
        for (const binary of this.TOOL_NAMES) {
            try {
                this.log.info(`     '${binary}' exists in ${await (0, appium_adb_1.getAndroidBinaryPath)(binary)}`);
            }
            catch (e) {
                missingBinaries.push(binary);
            }
        }
        if (missingBinaries.length > 0) {
            return support_1.doctor.nok(`${missingBinaries.join(', ')} could NOT be found in '${sdkRoot}'!`);
        }
        return support_1.doctor.ok(`${listOfTools} exist in '${sdkRoot}'`);
    }
    async fix() {
        return (`Manually install ${'Android SDK'.bold} and set ${'ANDROID_HOME'.bold}. ` +
            `Read ${[ANDROID_SDK_LINK1, ANDROID_SDK_LINK2].join(' and ')}.`);
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return false;
    }
}
exports.AndroidSdkCheck = AndroidSdkCheck;
exports.androidSdkCheck = new AndroidSdkCheck();
/** @satisfies {import('@appium/types').IDoctorCheck} */
class OptionalBundletoolCheck {
    async diagnose() {
        const bundletoolPath = await (0, utils_1.resolveExecutablePath)('bundletool.jar');
        return bundletoolPath
            ? support_1.doctor.okOptional(`bundletool.jar is installed at: ${bundletoolPath}`)
            : support_1.doctor.nokOptional('bundletool.jar cannot be found');
    }
    async fix() {
        return (`${'bundletool.jar'.bold} is used to handle Android App bundles. ` +
            `Please download the binary from ${BUNDLETOOL_RELEASES_LINK} and store it ` +
            `to any folder listed in the PATH environment variable. Folders that ` +
            `are currently present in PATH: ${process.env.PATH}`);
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return true;
    }
}
exports.OptionalBundletoolCheck = OptionalBundletoolCheck;
exports.optionalBundletoolCheck = new OptionalBundletoolCheck();
/** @satisfies {import('@appium/types').IDoctorCheck} */
class OptionalGstreamerCheck {
    constructor() {
        this.GSTREAMER_BINARY = `gst-launch-1.0${support_1.system.isWindows() ? '.exe' : ''}`;
        this.GST_INSPECT_BINARY = `gst-inspect-1.0${support_1.system.isWindows() ? '.exe' : ''}`;
    }
    async diagnose() {
        const gstreamerPath = await (0, utils_1.resolveExecutablePath)(this.GSTREAMER_BINARY);
        const gstInspectPath = await (0, utils_1.resolveExecutablePath)(this.GST_INSPECT_BINARY);
        return gstreamerPath && gstInspectPath
            ? support_1.doctor.okOptional(`${this.GSTREAMER_BINARY} and ${this.GST_INSPECT_BINARY} are installed at: ${gstreamerPath} and ${gstInspectPath}`)
            : support_1.doctor.nokOptional(`${this.GSTREAMER_BINARY} and/or ${this.GST_INSPECT_BINARY} cannot be found`);
    }
    async fix() {
        return (`${`${this.GSTREAMER_BINARY} and ${this.GST_INSPECT_BINARY}`.bold} are used to stream the screen of the device under test. ` +
            `Please read ${GSTREAMER_INSTALL_LINK}.`);
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return true;
    }
}
exports.OptionalGstreamerCheck = OptionalGstreamerCheck;
exports.optionalGstreamerCheck = new OptionalGstreamerCheck();
/** @satisfies {import('@appium/types').IDoctorCheck} */
class OptionalFfmpegCheck {
    constructor() {
        this.FFMPEG_BINARY = `ffmpeg${support_1.system.isWindows() ? '.exe' : ''}`;
    }
    async diagnose() {
        const ffmpegPath = await (0, utils_1.resolveExecutablePath)(this.FFMPEG_BINARY);
        return ffmpegPath
            ? support_1.doctor.okOptional(`${this.FFMPEG_BINARY} exists at '${ffmpegPath}'`)
            : support_1.doctor.nokOptional(`${this.FFMPEG_BINARY} cannot be found`);
    }
    async fix() {
        return (`${`${this.FFMPEG_BINARY}`.bold} is used to capture screen recordings from the device under test. ` +
            `Please read ${FFMPEG_INSTALL_LINK}.`);
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return true;
    }
}
exports.OptionalFfmpegCheck = OptionalFfmpegCheck;
exports.optionalFfmpegCheck = new OptionalFfmpegCheck();
//# sourceMappingURL=checks.js.map