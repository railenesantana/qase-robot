{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = (value: string) => value;\nconst ID_CHAR = /^\\p{XID_Continue}$/u;\n\n/**\n * Encode a string into another string.\n */\nexport type Encode = (value: string) => string;\n\n/**\n * Decode a string into another string.\n */\nexport type Decode = (value: string) => string;\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * Function for encoding input strings for output into path.\n   */\n  encodePath?: Encode;\n}\n\nexport interface PathToRegexpOptions extends ParseOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Allow delimiter to be arbitrarily repeated. (default: `true`)\n   */\n  loose?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * When `true` the regexp allows an optional trailing delimiter to match. (default: `true`)\n   */\n  trailing?: boolean;\n}\n\nexport interface MatchOptions extends PathToRegexpOptions {\n  /**\n   * Function for decoding strings for params, or `false` to disable entirely. (default: `decodeURIComponent`)\n   */\n  decode?: Decode | false;\n}\n\nexport interface CompileOptions extends ParseOptions {\n  /**\n   * When `true` the validation will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Allow delimiter to be arbitrarily repeated. (default: `true`)\n   */\n  loose?: boolean;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n  /**\n   * Function for encoding input strings for output into the path, or `false` to disable entirely. (default: `encodeURIComponent`)\n   */\n  encode?: Encode | false;\n}\n\ntype TokenType =\n  | \"{\"\n  | \"}\"\n  | \"*\"\n  | \"+\"\n  | \"?\"\n  | \"NAME\"\n  | \"PATTERN\"\n  | \"CHAR\"\n  | \"ESCAPED\"\n  | \"END\"\n  // Reserved for use.\n  | \"!\"\n  | \"@\"\n  | \",\"\n  | \";\";\n\n/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type: TokenType;\n  index: number;\n  value: string;\n}\n\nconst SIMPLE_TOKENS: Record<string, TokenType> = {\n  \"!\": \"!\",\n  \"@\": \"@\",\n  \";\": \";\",\n  \",\": \",\",\n  \"*\": \"*\",\n  \"+\": \"+\",\n  \"?\": \"?\",\n  \"{\": \"{\",\n  \"}\": \"}\",\n};\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string) {\n  const chars = [...str];\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < chars.length) {\n    const value = chars[i];\n    const type = SIMPLE_TOKENS[value];\n\n    if (type) {\n      tokens.push({ type, index: i++, value });\n      continue;\n    }\n\n    if (value === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED\", index: i++, value: chars[i++] });\n      continue;\n    }\n\n    if (value === \":\") {\n      let name = \"\";\n\n      while (ID_CHAR.test(chars[++i])) {\n        name += chars[i];\n      }\n\n      if (!name) {\n        throw new TypeError(`Missing parameter name at ${i}`);\n      }\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      continue;\n    }\n\n    if (value === \"(\") {\n      const pos = i++;\n      let count = 1;\n      let pattern = \"\";\n\n      if (chars[i] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${i}`);\n      }\n\n      while (i < chars.length) {\n        if (chars[i] === \"\\\\\") {\n          pattern += chars[i++] + chars[i++];\n          continue;\n        }\n\n        if (chars[i] === \")\") {\n          count--;\n          if (count === 0) {\n            i++;\n            break;\n          }\n        } else if (chars[i] === \"(\") {\n          count++;\n          if (chars[i + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${i}`);\n          }\n        }\n\n        pattern += chars[i++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${pos}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${pos}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: chars[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return new Iter(tokens);\n}\n\nclass Iter {\n  index = 0;\n\n  constructor(private tokens: LexToken[]) {}\n\n  peek(): LexToken {\n    return this.tokens[this.index];\n  }\n\n  tryConsume(type: LexToken[\"type\"]): string | undefined {\n    const token = this.peek();\n    if (token.type !== type) return;\n    this.index++;\n    return token.value;\n  }\n\n  consume(type: LexToken[\"type\"]): string {\n    const value = this.tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = this.peek();\n    throw new TypeError(\n      `Unexpected ${nextType} at ${index}, expected ${type}: https://git.new/pathToRegexpError`,\n    );\n  }\n\n  text(): string {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\"))) {\n      result += value;\n    }\n    return result;\n  }\n\n  modifier(): string {\n    return (\n      this.tryConsume(\"?\") || this.tryConsume(\"*\") || this.tryConsume(\"+\") || \"\"\n    );\n  }\n}\n\n/**\n * Tokenized path instance. Can we passed around instead of string.\n */\nexport class TokenData {\n  constructor(\n    public readonly tokens: Token[],\n    public readonly delimiter: string,\n  ) {}\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): TokenData {\n  const { delimiter = DEFAULT_DELIMITER, encodePath = NOOP_VALUE } = options;\n  const tokens: Token[] = [];\n  const it = lexer(str);\n  let key = 0;\n\n  do {\n    const path = it.text();\n    if (path) tokens.push(encodePath(path));\n\n    const name = it.tryConsume(\"NAME\");\n    const pattern = it.tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      tokens.push({\n        name: name || String(key++),\n        pattern,\n      });\n\n      const next = it.peek();\n      if (next.type === \"*\") {\n        throw new TypeError(\n          `Unexpected * at ${next.index}, you probably want \\`/*\\` or \\`{/:foo}*\\`: https://git.new/pathToRegexpError`,\n        );\n      }\n\n      continue;\n    }\n\n    const asterisk = it.tryConsume(\"*\");\n    if (asterisk) {\n      tokens.push({\n        name: String(key++),\n        pattern: `[^${escape(delimiter)}]*`,\n        modifier: \"*\",\n        separator: delimiter,\n      });\n      continue;\n    }\n\n    const open = it.tryConsume(\"{\");\n    if (open) {\n      const prefix = it.text();\n      const name = it.tryConsume(\"NAME\");\n      const pattern = it.tryConsume(\"PATTERN\");\n      const suffix = it.text();\n      const separator = it.tryConsume(\";\") ? it.text() : prefix + suffix;\n\n      it.consume(\"}\");\n\n      const modifier = it.modifier();\n\n      tokens.push({\n        name: name || (pattern ? String(key++) : \"\"),\n        prefix: encodePath(prefix),\n        suffix: encodePath(suffix),\n        pattern,\n        modifier,\n        separator,\n      });\n      continue;\n    }\n\n    it.consume(\"END\");\n    break;\n  } while (true);\n\n  return new TokenData(tokens, delimiter);\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  path: Path,\n  options: CompileOptions = {},\n) {\n  const data = path instanceof TokenData ? path : parse(path, options);\n  return compileTokens<P>(data, options);\n}\n\nexport type ParamData = Partial<Record<string, string | string[]>>;\nexport type PathFunction<P extends ParamData> = (data?: P) => string;\n\n/**\n * Convert a single token into a path building function.\n */\nfunction tokenToFunction(\n  token: Token,\n  encode: Encode | false,\n): (data: ParamData) => string {\n  if (typeof token === \"string\") {\n    return () => token;\n  }\n\n  const encodeValue = encode || NOOP_VALUE;\n  const repeated = token.modifier === \"+\" || token.modifier === \"*\";\n  const optional = token.modifier === \"?\" || token.modifier === \"*\";\n  const { prefix = \"\", suffix = \"\", separator = \"\" } = token;\n\n  if (encode && repeated) {\n    const stringify = (value: string, index: number) => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Expected \"${token.name}/${index}\" to be a string`);\n      }\n      return encodeValue(value);\n    };\n\n    const compile = (value: unknown) => {\n      if (!Array.isArray(value)) {\n        throw new TypeError(`Expected \"${token.name}\" to be an array`);\n      }\n\n      if (value.length === 0) return \"\";\n\n      return prefix + value.map(stringify).join(separator) + suffix;\n    };\n\n    if (optional) {\n      return (data): string => {\n        const value = data[token.name];\n        if (value == null) return \"\";\n        return value.length ? compile(value) : \"\";\n      };\n    }\n\n    return (data): string => {\n      const value = data[token.name];\n      return compile(value);\n    };\n  }\n\n  const stringify = (value: unknown) => {\n    if (typeof value !== \"string\") {\n      throw new TypeError(`Expected \"${token.name}\" to be a string`);\n    }\n    return prefix + encodeValue(value) + suffix;\n  };\n\n  if (optional) {\n    return (data): string => {\n      const value = data[token.name];\n      if (value == null) return \"\";\n      return stringify(value);\n    };\n  }\n\n  return (data): string => {\n    const value = data[token.name];\n    return stringify(value);\n  };\n}\n\n/**\n * Transform tokens into a path building function.\n */\nfunction compileTokens<P extends ParamData>(\n  data: TokenData,\n  options: CompileOptions,\n): PathFunction<P> {\n  const {\n    encode = encodeURIComponent,\n    loose = true,\n    validate = true,\n  } = options;\n  const reFlags = flags(options);\n  const stringify = toStringify(loose, data.delimiter);\n  const keyToRegexp = toKeyRegexp(stringify, data.delimiter);\n\n  // Compile all the tokens into regexps.\n  const encoders: Array<(data: ParamData) => string> = data.tokens.map(\n    (token) => {\n      const fn = tokenToFunction(token, encode);\n      if (!validate || typeof token === \"string\") return fn;\n\n      const pattern = keyToRegexp(token);\n      const validRe = new RegExp(`^${pattern}$`, reFlags);\n\n      return (data) => {\n        const value = fn(data);\n        if (!validRe.test(value)) {\n          throw new TypeError(\n            `Invalid value for \"${token.name}\": ${JSON.stringify(value)}`,\n          );\n        }\n        return value;\n      };\n    },\n  );\n\n  return function path(data: Record<string, any> = {}) {\n    let path = \"\";\n    for (const encoder of encoders) path += encoder(data);\n    return path;\n  };\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends ParamData> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends ParamData> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends ParamData> = (path: string) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends ParamData>(\n  path: Path,\n  options: MatchOptions = {},\n): MatchFunction<P> {\n  const { decode = decodeURIComponent, loose = true } = options;\n  const data = path instanceof TokenData ? path : parse(path, options);\n  const stringify = toStringify(loose, data.delimiter);\n  const keys: Key[] = [];\n  const re = tokensToRegexp(data, keys, options);\n\n  const decoders = keys.map((key) => {\n    if (decode && (key.modifier === \"+\" || key.modifier === \"*\")) {\n      const re = new RegExp(stringify(key.separator || \"\"), \"g\");\n      return (value: string) => value.split(re).map(decode);\n    }\n\n    return decode || NOOP_VALUE;\n  });\n\n  return function match(pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n      const decoder = decoders[i - 1];\n      params[key.name] = decoder(m[i]);\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escape(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Escape and repeat loose characters for regular expressions.\n */\nfunction looseReplacer(value: string, loose: string) {\n  return loose ? `${escape(value)}+` : escape(value);\n}\n\n/**\n * Encode all non-delimiter characters using the encode function.\n */\nfunction toStringify(loose: boolean, delimiter: string) {\n  if (!loose) return escape;\n\n  const re = new RegExp(`[^${escape(delimiter)}]+|(.)`, \"g\");\n  return (value: string) => value.replace(re, looseReplacer);\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options: { sensitive?: boolean }) {\n  return options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * A key is a capture group in the regex.\n */\nexport interface Key {\n  name: string;\n  prefix?: string;\n  suffix?: string;\n  pattern?: string;\n  modifier?: string;\n  separator?: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(\n  data: TokenData,\n  keys: Key[],\n  options: PathToRegexpOptions,\n): RegExp {\n  const { trailing = true, start = true, end = true, loose = true } = options;\n  const stringify = toStringify(loose, data.delimiter);\n  const keyToRegexp = toKeyRegexp(stringify, data.delimiter);\n  let pattern = start ? \"^\" : \"\";\n\n  for (const token of data.tokens) {\n    if (typeof token === \"string\") {\n      pattern += stringify(token);\n    } else {\n      if (token.name) keys.push(token);\n      pattern += keyToRegexp(token);\n    }\n  }\n\n  if (trailing) pattern += `(?:${stringify(data.delimiter)})?`;\n  pattern += end ? \"$\" : `(?=${escape(data.delimiter)}|$)`;\n\n  return new RegExp(pattern, flags(options));\n}\n\n/**\n * Convert a token into a regexp string (re-used for path validation).\n */\nfunction toKeyRegexp(stringify: Encode, delimiter: string) {\n  const segmentPattern = `[^${escape(delimiter)}]+?`;\n\n  return (key: Key) => {\n    const prefix = key.prefix ? stringify(key.prefix) : \"\";\n    const suffix = key.suffix ? stringify(key.suffix) : \"\";\n    const modifier = key.modifier || \"\";\n\n    if (key.name) {\n      const pattern = key.pattern || segmentPattern;\n      if (key.modifier === \"+\" || key.modifier === \"*\") {\n        const mod = key.modifier === \"*\" ? \"?\" : \"\";\n        const split = key.separator ? stringify(key.separator) : \"\";\n        return `(?:${prefix}((?:${pattern})(?:${split}(?:${pattern}))*)${suffix})${mod}`;\n      }\n      return `(?:${prefix}(${pattern})${suffix})${modifier}`;\n    }\n\n    return `(?:${prefix}${suffix})${modifier}`;\n  };\n}\n\n/**\n * Repeated and simple input types.\n */\nexport type Path = string | TokenData;\n\nexport type PathRegExp = RegExp & { keys: Key[] };\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path: Path, options: PathToRegexpOptions = {}) {\n  const data = path instanceof TokenData ? path : parse(path, options);\n  const keys: Key[] = [];\n  const regexp = tokensToRegexp(data, keys, options);\n  return Object.assign(regexp, { keys });\n}\n"]}